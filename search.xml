<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[26. linux利用socat虚拟串口]]></title>
    <url>%2F2020%2F06%2F16%2F26-linux%E5%88%A9%E7%94%A8socat%E8%99%9A%E6%8B%9F%E4%B8%B2%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[Socat 是 Linux 下的一个多功能的网络工具，名字来由是 「Socket CAT」。其功能与有瑞士军刀之称的 Netcat 类似，可以看做是 Netcat 的加强版。 Socat安装1$ sudo apt install socat 创建虚拟串口1234$ socat -d -d pty,raw,echo=0 pty,raw,echo=02020/06/16 13:42:10 socat[6958] N PTY is /dev/pts/22020/06/16 13:42:10 socat[6958] N PTY is /dev/pts/32020/06/16 13:42:10 socat[6958] N starting data transfer loop with FDs [5,5] and [7,7] 现在/dev/pts/2和/dev/pts/3可以互通了 帮助123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117$ sicat -hsocat by Gerhard Rieger and contributors - see www.dest-unreach.orgUsage:socat [options] &lt;bi-address&gt; &lt;bi-address&gt; options: -V print version and feature information to stdout, and exit -h|-? print a help text describing command line options and addresses -hh like -h, plus a list of all common address option names -hhh like -hh, plus a list of all available address option names -d increase verbosity (use up to 4 times; 2 are recommended) -D analyze file descriptors before loop -ly[facility] log to syslog, using facility (default is daemon) -lf&lt;logfile&gt; log to file -ls log to stderr (default if no other log) -lm[facility] mixed log mode (stderr during initialization, then syslog) -lp&lt;progname&gt; set the program name used for logging -lu use microseconds for logging timestamps -lh add hostname to log messages -v verbose data traffic, text -x verbose data traffic, hexadecimal -b&lt;size_t&gt; set data buffer size (8192) -s sloppy (continue on error) -t&lt;timeout&gt; wait seconds before closing second channel -T&lt;timeout&gt; total inactivity timeout in seconds -u unidirectional mode (left to right) -U unidirectional mode (right to left) -g do not check option groups -L &lt;lockfile&gt; try to obtain lock, or fail -W &lt;lockfile&gt; try to obtain lock, or wait -4 prefer IPv4 if version is not explicitly specified -6 prefer IPv6 if version is not explicitly specified bi-address: pipe[,&lt;opts&gt;] groups=FD,FIFO &lt;single-address&gt;!!&lt;single-address&gt; &lt;single-address&gt; single-address: &lt;address-head&gt;[,&lt;opts&gt;] address-head: abstract-client:&lt;filename&gt; groups=FD,SOCKET,RETRY,UNIX abstract-connect:&lt;filename&gt; groups=FD,SOCKET,RETRY,UNIX abstract-listen:&lt;filename&gt; groups=FD,SOCKET,LISTEN,CHILD,RETRY,UNIX abstract-recv:&lt;filename&gt; groups=FD,SOCKET,RETRY,UNIX abstract-recvfrom:&lt;filename&gt; groups=FD,SOCKET,CHILD,RETRY,UNIX abstract-sendto:&lt;filename&gt; groups=FD,SOCKET,RETRY,UNIX create:&lt;filename&gt; groups=FD,REG,NAMED exec:&lt;command-line&gt; groups=FD,FIFO,SOCKET,EXEC,FORK,TERMIOS,PTY,PARENT,UNIX fd:&lt;num&gt; groups=FD,FIFO,CHR,BLK,REG,SOCKET,TERMIOS,UNIX,IP4,IP6,UDP,TCP,SCTP gopen:&lt;filename&gt; groups=FD,FIFO,CHR,BLK,REG,SOCKET,NAMED,OPEN,TERMIOS,UNIX interface:&lt;interface&gt; groups=FD,SOCKET ip-datagram:&lt;host&gt;:&lt;protocol&gt; groups=FD,SOCKET,RANGE,IP4,IP6 ip-recv:&lt;protocol&gt; groups=FD,SOCKET,RANGE,IP4,IP6 ip-recvfrom:&lt;protocol&gt; groups=FD,SOCKET,CHILD,RANGE,IP4,IP6 ip-sendto:&lt;host&gt;:&lt;protocol&gt; groups=FD,SOCKET,IP4,IP6 ip4-datagram:&lt;host&gt;:&lt;protocol&gt; groups=FD,SOCKET,RANGE,IP4 ip4-recv:&lt;protocol&gt; groups=FD,SOCKET,RANGE,IP4 ip4-recvfrom:&lt;protocol&gt; groups=FD,SOCKET,CHILD,RANGE,IP4 ip4-sendto:&lt;host&gt;:&lt;protocol&gt; groups=FD,SOCKET,IP4 ip6-datagram:&lt;host&gt;:&lt;protocol&gt; groups=FD,SOCKET,RANGE,IP6 ip6-recv:&lt;protocol&gt; groups=FD,SOCKET,RANGE,IP6 ip6-recvfrom:&lt;protocol&gt; groups=FD,SOCKET,CHILD,RANGE,IP6 ip6-sendto:&lt;host&gt;:&lt;protocol&gt; groups=FD,SOCKET,IP6 open:&lt;filename&gt; groups=FD,FIFO,CHR,BLK,REG,NAMED,OPEN,TERMIOS openssl:&lt;host&gt;:&lt;port&gt; groups=FD,SOCKET,CHILD,RETRY,IP4,IP6,TCP,OPENSSL openssl-listen:&lt;port&gt; groups=FD,SOCKET,LISTEN,CHILD,RETRY,RANGE,IP4,IP6,TCP,OPENSSL pipe:&lt;filename&gt; groups=FD,FIFO,NAMED,OPEN proxy:&lt;proxy-server&gt;:&lt;host&gt;:&lt;port&gt; groups=FD,SOCKET,CHILD,RETRY,IP4,IP6,TCP,HTTP pty groups=FD,NAMED,TERMIOS,PTY sctp-connect:&lt;host&gt;:&lt;port&gt; groups=FD,SOCKET,CHILD,RETRY,IP4,IP6,SCTP sctp-listen:&lt;port&gt; groups=FD,SOCKET,LISTEN,CHILD,RETRY,RANGE,IP4,IP6,SCTP sctp4-connect:&lt;host&gt;:&lt;port&gt; groups=FD,SOCKET,CHILD,RETRY,IP4,SCTP sctp4-listen:&lt;port&gt; groups=FD,SOCKET,LISTEN,CHILD,RETRY,RANGE,IP4,SCTP sctp6-connect:&lt;host&gt;:&lt;port&gt; groups=FD,SOCKET,CHILD,RETRY,IP6,SCTP sctp6-listen:&lt;port&gt; groups=FD,SOCKET,LISTEN,CHILD,RETRY,RANGE,IP6,SCTP socket-connect:&lt;domain&gt;:&lt;protocol&gt;:&lt;remote-address&gt; groups=FD,SOCKET,CHILD,RETRY socket-datagram:&lt;domain&gt;:&lt;type&gt;:&lt;protocol&gt;:&lt;remote-address&gt; groups=FD,SOCKET,RANGE socket-listen:&lt;domain&gt;:&lt;protocol&gt;:&lt;local-address&gt; groups=FD,SOCKET,LISTEN,CHILD,RETRY,RANGE socket-recv:&lt;domain&gt;:&lt;type&gt;:&lt;protocol&gt;:&lt;local-address&gt; groups=FD,SOCKET,RANGE socket-recvfrom:&lt;domain&gt;:&lt;type&gt;:&lt;protocol&gt;:&lt;local-address&gt; groups=FD,SOCKET,CHILD,RANGE socket-sendto:&lt;domain&gt;:&lt;type&gt;:&lt;protocol&gt;:&lt;remote-address&gt; groups=FD,SOCKET socks4:&lt;socks-server&gt;:&lt;host&gt;:&lt;port&gt; groups=FD,SOCKET,CHILD,RETRY,IP4,IP6,TCP,SOCKS4 socks4a:&lt;socks-server&gt;:&lt;host&gt;:&lt;port&gt; groups=FD,SOCKET,CHILD,RETRY,IP4,IP6,TCP,SOCKS4 stderr groups=FD,FIFO,CHR,BLK,REG,SOCKET,TERMIOS,UNIX,IP4,IP6,UDP,TCP,SCTP stdin groups=FD,FIFO,CHR,BLK,REG,SOCKET,TERMIOS,UNIX,IP4,IP6,UDP,TCP,SCTP stdio groups=FD,FIFO,CHR,BLK,REG,SOCKET,TERMIOS,UNIX,IP4,IP6,UDP,TCP,SCTP stdout groups=FD,FIFO,CHR,BLK,REG,SOCKET,TERMIOS,UNIX,IP4,IP6,UDP,TCP,SCTP system:&lt;shell-command&gt; groups=FD,FIFO,SOCKET,EXEC,FORK,TERMIOS,PTY,PARENT,UNIX tcp-connect:&lt;host&gt;:&lt;port&gt; groups=FD,SOCKET,CHILD,RETRY,IP4,IP6,TCP tcp-listen:&lt;port&gt; groups=FD,SOCKET,LISTEN,CHILD,RETRY,RANGE,IP4,IP6,TCP tcp4-connect:&lt;host&gt;:&lt;port&gt; groups=FD,SOCKET,CHILD,RETRY,IP4,TCP tcp4-listen:&lt;port&gt; groups=FD,SOCKET,LISTEN,CHILD,RETRY,RANGE,IP4,TCP tcp6-connect:&lt;host&gt;:&lt;port&gt; groups=FD,SOCKET,CHILD,RETRY,IP6,TCP tcp6-listen:&lt;port&gt; groups=FD,SOCKET,LISTEN,CHILD,RETRY,RANGE,IP6,TCP tun[:&lt;ip-addr&gt;/&lt;bits&gt;] groups=FD,CHR,NAMED,OPEN,INTERFACE udp-connect:&lt;host&gt;:&lt;port&gt; groups=FD,SOCKET,IP4,IP6,UDP udp-datagram:&lt;host&gt;:&lt;port&gt; groups=FD,SOCKET,RANGE,IP4,IP6,UDP udp-listen:&lt;port&gt; groups=FD,SOCKET,LISTEN,CHILD,RANGE,IP4,IP6,UDP udp-recv:&lt;port&gt; groups=FD,SOCKET,RANGE,IP4,IP6,UDP udp-recvfrom:&lt;port&gt; groups=FD,SOCKET,CHILD,RANGE,IP4,IP6,UDP udp-sendto:&lt;host&gt;:&lt;port&gt; groups=FD,SOCKET,IP4,IP6,UDP udp4-connect:&lt;host&gt;:&lt;port&gt; groups=FD,SOCKET,IP4,UDP udp4-datagram:&lt;remote-address&gt;:&lt;port&gt; groups=FD,SOCKET,RANGE,IP4,UDP udp4-listen:&lt;port&gt; groups=FD,SOCKET,LISTEN,CHILD,RANGE,IP4,UDP udp4-recv:&lt;port&gt; groups=FD,SOCKET,RANGE,IP4,UDP udp4-recvfrom:&lt;host&gt;:&lt;port&gt; groups=FD,SOCKET,CHILD,RANGE,IP4,UDP udp4-sendto:&lt;host&gt;:&lt;port&gt; groups=FD,SOCKET,IP4,UDP udp6-connect:&lt;host&gt;:&lt;port&gt; groups=FD,SOCKET,IP6,UDP udp6-datagram:&lt;host&gt;:&lt;port&gt; groups=FD,SOCKET,RANGE,IP6,UDP udp6-listen:&lt;port&gt; groups=FD,SOCKET,LISTEN,CHILD,RANGE,IP6,UDP udp6-recv:&lt;port&gt; groups=FD,SOCKET,RANGE,IP6,UDP udp6-recvfrom:&lt;port&gt; groups=FD,SOCKET,CHILD,RANGE,IP6,UDP udp6-sendto:&lt;host&gt;:&lt;port&gt; groups=FD,SOCKET,IP6,UDP unix-client:&lt;filename&gt; groups=FD,SOCKET,NAMED,RETRY,UNIX unix-connect:&lt;filename&gt; groups=FD,SOCKET,NAMED,RETRY,UNIX unix-listen:&lt;filename&gt; groups=FD,SOCKET,NAMED,LISTEN,CHILD,RETRY,UNIX unix-recv:&lt;filename&gt; groups=FD,SOCKET,NAMED,RETRY,UNIX unix-recvfrom:&lt;filename&gt; groups=FD,SOCKET,NAMED,CHILD,RETRY,UNIX unix-sendto:&lt;filename&gt; groups=FD,SOCKET,NAMED,RETRY,UNIX]]></content>
      <categories>
        <category>Linux</category>
        <category>Softwares</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>serial</tag>
        <tag>socat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[25. sdcc编译器编译步骤]]></title>
    <url>%2F2020%2F05%2F22%2F25-sdcc%E7%BC%96%E8%AF%91%E5%99%A8%E7%BC%96%E8%AF%91%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[下载sdcc源码 http://sdcc.sourceforge.net 解压 12tar -xjvf sdcc-src-4.0.0.tar.bz2cd sdcc-4.0.0 安装依赖 1sudo apt install flex bison texinfo libboost1.62-dev configure 禁用不必要的芯片支持，只保留mcs51和stm8 1./configure --disable-z80-port --disable-z180-port --disable-r2k-port --disable-r3ka-port --disable-gbz80-port --disable-tlcs90-port --disable-ez80_z80-port --disable-ds390-port --disable-ds400-port --disable-pic14-port --disable-pic16-port --disable-hc08-port --disable-s08-port --disable-pdk13-port --disable-pdk14-port --disable-pdk15-port 编译安装 12makesudo make install]]></content>
      <tags>
        <tag>sdcc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[24. rsync+inotify-tools实现文件夹双向同步]]></title>
    <url>%2F2020%2F03%2F13%2F24-rsync-inotify-tools%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E5%A4%B9%E5%8F%8C%E5%90%91%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[基于Ubuntu Linux，适用于大多数Debian发行版。 环境1234操作系统：Ubuntu 18.04文件夹： - /home/hungtcs/Temp/d1 - /home/hungtcs/Temp/d2 安装1sudo apt install rsync inotify-tools rsync主要参数123456789--links copy symlinks as symlinks--delete 允许删除文件--sparse handle sparse files efficiently--backup make backups (see --suffix &amp; --backup-dir)--backup-dir=DIR make backups into hierarchy based in DIR--archive archive mode; equals -rlptgoD (no -H,-A,-X)--verbose 显示详细输出--recursive 递归同步文件夹内容--human-readable output numbers in a human-readable format 同步文件夹d1到d21rsync --verbose --recursive --archive --delete --human-readable --sparse ./d1/ ./d2/ 监听文件更改1inotifywait --recursive --event=modify,create,delete,move ./d1 监听文件夹d1改动并同步d2123while inotifywait --recursive --event=modify,create,delete,move ./d1; do rsync --verbose --recursive --archive --delete --human-readable --sparse ./d1/ ./d2/done 监听文件夹d2改动并同步到d1123while inotifywait --recursive --event=modify,create,delete,move ./d2; do rsync --verbose --recursive --archive --delete --human-readable --sparse ./d2/ ./d1/done]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>rsync</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[23. K8S安装过程笔记]]></title>
    <url>%2F2019%2F11%2F27%2F23-K8S%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[以下所有操作均基于Cent OS 7操作系统。 视频教程连接：Bilibili Youtube 基本环境配置 关闭selinux12setenforce 0sed -i &quot;s/SELINUX=enforcing/SELINUX=disabled/g&quot; /etc/selinux/config 关闭swap分区或禁用swap文件1234swapoff -a# 注释掉关于swap分区的行yes | cp /etc/fstab /etc/fstab_bakcat /etc/fstab_bak |grep -v swap &gt; /etc/fstab 修改网卡配置12345$ vim /etc/sysctl.confnet.ipv4.ip_forward = 1net.bridge.bridge-nf-call-iptables = 1net.bridge.bridge-nf-call-ip6tables = 1$ sysctl -p 启用内核模块123456789101112$ modprobe -- ip_vs$ modprobe -- ip_vs_rr$ modprobe -- ip_vs_wrr$ modprobe -- ip_vs_sh$ modprobe -- nf_conntrack_ipv4$ cut -f1 -d &quot; &quot; /proc/modules | grep -e ip_vs -e nf_conntrack_ipv4$ vim /etc/sysconfig/modules/ipvs.modulesmodprobe -- ip_vsmodprobe -- ip_vs_rrmodprobe -- ip_vs_wrrmodprobe -- ip_vs_shmodprobe -- nf_conntrack_ipv4 关闭防火墙12$ systemctl stop firewalld$ systemctl disable firewalld 配置hosts kubectl、kubeadm、kubelet的安装添加Kubernetes的yum源此处使用alibaba的镜像源 123456789$vim /etc/yum.repos.d/kubernetes.repo[kubernetes]name=Kubernetesbaseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64enabled=1gpgcheck=0repo_gpgcheck=0gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg 安装kubelet、kubeadm、kubectl1$ yum install -y kubelet kubeadm kubectl 启动kubelet服务12$ systemctl enable kubelet$ systemctl start kubelet 此时执行systemctl status kubelet查看服务状态，服务状态应为Error(255)， 如果是其他错误可使用journalctl -xe查看错误信息。 Docker安装和配置Docker安装docker的安装请查看官网文档(Overview of Docker editions)[https://docs.docker.com/install/overview/] Docker配置 配置cgroup-driver为systemd123456789101112# 查看cgroup-driver$ docker info | grep -i cgroup# 追加 --exec-opt native.cgroupdriver=systemd 参数$ sed -i &quot;s#^ExecStart=/usr/bin/dockerd.*#ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --exec-opt native.cgroupdriver=systemd#g&quot; /usr/lib/systemd/system/docker.service$ systemctl daemon-reload # 重新加载服务$ systemctl enable docker # 启用docker服务(开机自起)$ systemctl restart docker # 启动docker服务# 或者修改docker配置文件$ vim /etc/docker/daemon.json&#123; &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;]&#125; 预先拉取所需镜像1234567891011121314151617# 查看kubeadm所需镜像$ kubeadm config images listk8s.gcr.io/kube-apiserver:v1.16.3k8s.gcr.io/kube-controller-manager:v1.16.3k8s.gcr.io/kube-scheduler:v1.16.3k8s.gcr.io/kube-proxy:v1.16.3k8s.gcr.io/pause:3.1k8s.gcr.io/etcd:3.3.15-0k8s.gcr.io/coredns:1.6.2# 拉取镜像$ docker pull kubeimage/kube-apiserver-amd64:v1.16.3$ docker pull kubeimage/kube-controller-manager-amd64:v1.16.3$ docker pull kubeimage/kube-scheduler-amd64:v1.16.3$ docker pull kubeimage/kube-proxy-amd64:v1.16.3$ docker pull kubeimage/pause-amd64:3.1$ docker pull kubeimage/etcd-amd64:3.3.15-0$ docker pull coredns/coredns:1.6.2 对预先拉取的镜像重新打tag1234567$ docker tag kubeimage/kube-apiserver-amd64:v1.16.3 k8s.gcr.io/kube-apiserver:v1.16.3$ docker tag kubeimage/kube-controller-manager-amd64:v1.16.3 k8s.gcr.io/kube-controller-manager:v1.16.3$ docker tag kubeimage/kube-scheduler-amd64:v1.16.3 k8s.gcr.io/kube-scheduler:v1.16.3$ docker tag kubeimage/kube-proxy-amd64:v1.16.3 k8s.gcr.io/kube-proxy:v1.16.3$ docker tag kubeimage/pause-amd64:3.1 k8s.gcr.io/pause:3.1$ docker tag kubeimage/etcd-amd64:3.3.15-0 k8s.gcr.io/etcd:3.3.15-0$ docker tag coredns/coredns:1.6.2 k8s.gcr.io/coredns:1.6.2 Master节点的配置以上步骤需要在node节点和master节点执行，当前步骤仅需在master节点执行。 Master节点的初始化123456# 初始化master节点，# --pod-network-cidr=192.168.0.0/16 指定使用Calico网络# --apiserver-advertise-address=10.0.0.5 指向master节点IP，此处也可以使用hosts$ kubeadm init --pod-network-cidr=10.244.0.0/16 \ --kubernetes-version=v1.16.3 \ --apiserver-advertise-address=10.0.0.5 执行上述命令的输出为： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566[init] Using Kubernetes version: v1.16.3[preflight] Running pre-flight checks [WARNING SystemVerification]: this Docker version is not on the list of validated versions: 19.03.4. Latest validated version: 18.09[preflight] Pulling images required for setting up a Kubernetes cluster[preflight] This might take a minute or two, depending on the speed of your internet connection[preflight] You can also perform this action in beforehand using &#x27;kubeadm config images pull&#x27;[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;[kubelet-start] Activating the kubelet service[certs] Using certificateDir folder &quot;/etc/kubernetes/pki&quot;[certs] Generating &quot;ca&quot; certificate and key[certs] Generating &quot;apiserver&quot; certificate and key[certs] apiserver serving cert is signed for DNS names [master kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local] and IPs [10.96.0.1 10.0.0.5][certs] Generating &quot;apiserver-kubelet-client&quot; certificate and key[certs] Generating &quot;front-proxy-ca&quot; certificate and key[certs] Generating &quot;front-proxy-client&quot; certificate and key[certs] Generating &quot;etcd/ca&quot; certificate and key[certs] Generating &quot;etcd/server&quot; certificate and key[certs] etcd/server serving cert is signed for DNS names [master localhost] and IPs [10.0.0.5 127.0.0.1 ::1][certs] Generating &quot;etcd/peer&quot; certificate and key[certs] etcd/peer serving cert is signed for DNS names [master localhost] and IPs [10.0.0.5 127.0.0.1 ::1][certs] Generating &quot;etcd/healthcheck-client&quot; certificate and key[certs] Generating &quot;apiserver-etcd-client&quot; certificate and key[certs] Generating &quot;sa&quot; key and public key[kubeconfig] Using kubeconfig folder &quot;/etc/kubernetes&quot;[kubeconfig] Writing &quot;admin.conf&quot; kubeconfig file[kubeconfig] Writing &quot;kubelet.conf&quot; kubeconfig file[kubeconfig] Writing &quot;controller-manager.conf&quot; kubeconfig file[kubeconfig] Writing &quot;scheduler.conf&quot; kubeconfig file[control-plane] Using manifest folder &quot;/etc/kubernetes/manifests&quot;[control-plane] Creating static Pod manifest for &quot;kube-apiserver&quot;[control-plane] Creating static Pod manifest for &quot;kube-controller-manager&quot;[control-plane] Creating static Pod manifest for &quot;kube-scheduler&quot;[etcd] Creating static Pod manifest for local etcd in &quot;/etc/kubernetes/manifests&quot;[wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory &quot;/etc/kubernetes/manifests&quot;. This can take up to 4m0s[apiclient] All control plane components are healthy after 13.002108 seconds[upload-config] Storing the configuration used in ConfigMap &quot;kubeadm-config&quot; in the &quot;kube-system&quot; Namespace[kubelet] Creating a ConfigMap &quot;kubelet-config-1.16&quot; in namespace kube-system with the configuration for the kubelets in the cluster[upload-certs] Skipping phase. Please see --upload-certs[mark-control-plane] Marking the node master as control-plane by adding the label &quot;node-role.kubernetes.io/master=&#x27;&#x27;&quot;[mark-control-plane] Marking the node master as control-plane by adding the taints [node-role.kubernetes.io/master:NoSchedule][bootstrap-token] Using token: kt58np.djd3youoqb0bnz4r[bootstrap-token] Configuring bootstrap tokens, cluster-info ConfigMap, RBAC Roles[bootstrap-token] configured RBAC rules to allow Node Bootstrap tokens to post CSRs in order for nodes to get long term certificate credentials[bootstrap-token] configured RBAC rules to allow the csrapprover controller automatically approve CSRs from a Node Bootstrap Token[bootstrap-token] configured RBAC rules to allow certificate rotation for all node client certificates in the cluster[bootstrap-token] Creating the &quot;cluster-info&quot; ConfigMap in the &quot;kube-public&quot; namespace[addons] Applied essential addon: CoreDNS[addons] Applied essential addon: kube-proxyYour Kubernetes control-plane has initialized successfully!To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/configYou should now deploy a pod network to the cluster.Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/Then you can join any number of worker nodes by running the following on each as root:kubeadm join 10.0.0.5:6443 --token kt58np.djd3youoqb0bnz4r \ --discovery-token-ca-cert-hash sha256:37a3924142dc6d57eac2714e539c174ee3b0cda723746ada2464ac9e8a2091ce 保存输出中的kubeadm join部分内容，用于添加node节点，或者使用kubeadm token list 和kubeadm token create --print-join-command查看 12$ kubeadm join 10.0.0.5:6443 --token kt58np.djd3youoqb0bnz4r \ --discovery-token-ca-cert-hash sha256:37a3924142dc6d57eac2714e539c174ee3b0cda723746ada2464ac9e8a2091ce 接下来执行剩余的初始化步骤 123$ mkdir -p $HOME/.kube$ sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config$ sudo chown $(id -u):$(id -g) $HOME/.kube/config Calico网络插件的配置Calico的官方文档地址为： https://docs.projectcalico.org/v3.10/getting-started/kubernetes/。 具体安装步骤： 安装Calico1$ kubectl apply -f https://docs.projectcalico.org/v3.10/manifests/calico.yaml 监听安装进度1$ watch kubectl get pods --all-namespaces 出现以下内容时为安装成功12345678910NAMESPACE NAME READY STATUS RESTARTS AGEkube-system calico-kube-controllers-6ff88bf6d4-tgtzb 1/1 Running 0 2m45skube-system calico-node-24h85 1/1 Running 0 2m43skube-system coredns-846jhw23g9-9af73 1/1 Running 0 4m5skube-system coredns-846jhw23g9-hmswk 1/1 Running 0 4m5skube-system etcd-jbaker-1 1/1 Running 0 6m22skube-system kube-apiserver-jbaker-1 1/1 Running 0 6m12skube-system kube-controller-manager-jbaker-1 1/1 Running 0 6m16skube-system kube-proxy-8fzp2 1/1 Running 0 5m16skube-system kube-scheduler-jbaker-1 1/1 Running 0 5m41s 测试123$ kubectl get nodes -o wideNAME STATUS ROLES AGE VERSION INTERNAL-IP EXTERNAL-IP OS-IMAGE KERNEL-VERSION CONTAINER-RUNTIMEkubernetes-master Ready master 4d12h v1.16.3 192.168.56.101 &lt;none&gt; CentOS Linux 7 (Core) 3.10.0-1062.el7.x86_64 docker://19.3.4 Node节点的初始化 登录node节点，执行加入集群的命令，完成加入集群操作12$ kubeadm join 10.0.0.5:6443 --token kt58np.djd3youoqb0bnz4r \ --discovery-token-ca-cert-hash sha256:37a3924142dc6d57eac2714e539c174ee3b0cda723746ada2464ac9e8a2091ce 在master节点上查看添加结果1234$ kubectl get nodes -o wideNAME STATUS ROLES AGE VERSION INTERNAL-IP EXTERNAL-IP OS-IMAGE KERNEL-VERSION CONTAINER-RUNTIMEkubernetes-master Ready master 4d12h v1.16.3 192.168.56.101 &lt;none&gt; CentOS Linux 7 (Core) 3.10.0-1062.el7.x86_64 docker://19.3.4kubernetes-node-1 Ready &lt;none&gt; 4d12h v1.16.3 192.168.56.102 &lt;none&gt; CentOS Linux 7 (Core) 3.10.0-1062.el7.x86_64 docker://19.3.4]]></content>
      <tags>
        <tag>Kubernetes</tag>
        <tag>K8S</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[22. 简单实现类似Angular的依赖注入功能]]></title>
    <url>%2F2019%2F09%2F06%2F22-%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BCAngular%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[依赖注入是一个很重要的设计模式。 它使用得非常广泛，以至于几乎每个人都把它简称为 DI 。 Angular 有自己的依赖注入框架，离开它，你几乎没办法构建出 Angular 应用。 下面介绍一种简单的（只有100行左右代码）实现类似Angular依赖注入的方式，先看一个例子 123456789101112131415161718192021222324252627282930313233343536373839// a.service.ts@Injectable()export class AService &#123; constructor() &#123; &#125; public doSomething() &#123; console.log(&#x27;this is AService::doSomething&#x27;); &#125;&#125;// b.service.ts@Injectable()export class BService &#123; constructor(private readonly a: AService) &#123; &#125; public doSomething() &#123; this.a.doSomething(); console.log(&#x27;this is BService::doSomething&#x27;); &#125;&#125;// some.module.ts@Module(&#123; providers: [ AService, BService, ],&#125;)export class SomeModule &#123;&#125; 在上面的例子中，我们创建了两个Service，其中BService依赖于AService，那么BService可以在其构造函数中声明其依赖，我们需要一种方法去自动将AService的实例注入到BService的私有只读变量a中，接下来介绍实现的步骤。 首先我们应该对Typescript进行配置，使其支持Javascript的装饰器（或者说是注解）,下面是我的配置文件： 123456789101112131415&#123; &quot;compilerOptions&quot;: &#123; &quot;lib&quot;: [ &quot;dom&quot;, &quot;es2015&quot; ], &quot;target&quot;: &quot;es5&quot;, &quot;module&quot;: &quot;commonjs&quot;, &quot;outDir&quot;: &quot;./dist&quot;, &quot;strict&quot;: true, &quot;esModuleInterop&quot;: true, &quot;experimentalDecorators&quot;: true, &quot;emitDecoratorMetadata&quot;: true &#125;&#125; 其中，experimentalDecorators表示为ES装饰器启用实验支持，emitDecoratorMetadata表示在源代码中为装饰声明产生类型的元数据，配置好了这两项之后，我们才能使用Typescript的装饰器，接下来我们需要安装依赖reflect-metadata，用于读取和设置元数据。 @Injectable的实现@Injectable是一个装饰器，它标识被装饰的类是一个Provider，它的声明方式如下 12345export function Injectable(): ClassDecorator &#123; return (target) =&gt; &#123; &#125;;&#125; 我们在此装饰器中什么都不做，他只起到一个标识的作用。 @Module的实现@Module是一个装饰器，它标识被装饰的类是一个Module，它的声明方式如下 123456789const DI_IMPORTS_SYMBOL = Symbol(&#x27;di:imports&#x27;)const DI_PROVIDERS_SYMBOL = Symbol(&#x27;di:providers&#x27;)export function Module(options: &#123; imports?: Array&lt;any&gt;, providers?: Array&lt;any&gt; &#125;): ClassDecorator &#123; return (target) =&gt; &#123; Reflect.defineMetadata(DI_IMPORTS_SYMBOL, new Set(options.imports || []), target); Reflect.defineMetadata(DI_PROVIDERS_SYMBOL, new Set(options.providers || []), target); &#125;&#125; 我们使用Set来存储一个Module作用域中它所声明的Providers和它所引入的其他模块。 Factory的实现我们希望达到的目的是，在使用时可以通过Factory.create(SomeModule)来获取一个Module的实例，然后通过Module实例来获取一个Provider，例如Factory.create(SomeModule).get(BService).doSomething()，此时应该输出 123Factory.create(SomeModule).get(BService).doSomething();// this is AService::doSomething// this is BService::doSomething Talk is cheap. Show me the code: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081export namespace Factory &#123; export function create(module: Type) &#123; const imports: Set&lt;Type&gt; = Reflect.getMetadata(DI_IMPORTS_SYMBOL, module); const providers: Set&lt;any&gt; = Reflect.getMetadata(DI_PROVIDERS_SYMBOL, module); const providersMap = new Map(); const importModules = Array.from(imports).map((importModule) =&gt; &#123; let moduleInstance: ModuleInstance = moduleInstances.get(importModule); if(!moduleInstance) &#123; moduleInstance = create(importModule); moduleInstances.set(importModule, moduleInstance); &#125; return moduleInstance; &#125;); const moduleInstance = new ModuleInstance(importModules, providersMap); providers.forEach(provider =&gt; &#123; createProvider(provider, providers, moduleInstance); &#125;); return moduleInstance; &#125; function createProvider(provider: any, providers: Set&lt;any&gt;, moduleInstance: ModuleInstance) &#123; let providerInstance = moduleInstance.providers.get(provider); if(providerInstance) &#123; return providerInstance; &#125; const deps: Array&lt;any&gt; = Reflect.getMetadata(&#x27;design:paramtypes&#x27;, provider); if(!deps) &#123; throw new Error(`No provider named $&#123; provider.name &#125;, do yout add @Injectable() to this provider?`); &#125; const args = deps.map(dep =&gt; &#123; let depInstance = moduleInstance.providers.get(dep); if(!depInstance) &#123; if(providers.has(dep)) &#123; depInstance = createProvider(dep, providers, moduleInstance); &#125; else &#123; moduleInstance.imports.some(imp =&gt; &#123; depInstance = createProvider(dep, new Set(), imp); return !!depInstance; &#125;); &#125; &#125; if(!depInstance) &#123; throw new Error(`can not found provider $&#123; dep.name &#125;`); &#125; return depInstance; &#125;); providerInstance = new provider(...args); moduleInstance.providers.set(provider, providerInstance); return providerInstance; &#125; export class ModuleInstance &#123; constructor( public imports: Array&lt;ModuleInstance&gt;, public providers: Map&lt;any, any&gt;) &#123; &#125; get&lt;T&gt;(provider: Type&lt;T&gt;) &#123; let instance: T = this.providers.get(provider); if(!instance) &#123; this.imports.some(imp =&gt; &#123; instance = imp.get(provider); return !!instance; &#125;); &#125; if(!instance) &#123; throw new Error(`No provider named: $&#123; provider.name &#125;`); &#125; return instance; &#125; &#125;&#125; 以上就是整个依赖注入的实现了，感兴趣的朋友可以到我的Github上面查看源代码，核心文件就是lib/di.ts，地址是 https://github.com/hungtcs/light-di/blob/master/lib/di.ts]]></content>
      <categories>
        <category>前端开发</category>
        <category>Angular</category>
      </categories>
      <tags>
        <tag>Angular</tag>
        <tag>DI</tag>
        <tag>Typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[21. SD卡介绍]]></title>
    <url>%2F2019%2F03%2F24%2F21-SD%E5%8D%A1%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[SD卡简介SD卡（Secure Digital Memory Card）的技术建是基于MultiMedia卡（MMC）格式上发展而来，大小和MMC差不多，SD卡与MMC卡保持着向上兼容，也就是说，MMC可以被新的SD设备存取，兼容性则取决于应用软件，但SD卡却不可以被MMC设备存取。（SD卡外型采用了与MMC厚度一样的导轨式设计，以使SD设备可以适合MMC)。 设有SD卡插槽的设备能够使用较簿身的MMC卡，但是标准的SD卡却不能插入到MMC卡插槽。SD卡能够于CF卡和PCMCIA卡上，插上转接器使用； 而miniSD卡和microSD卡亦能插上转接器于SD卡插槽使用。 SD卡的引脚定义 寄存器 名称 宽度 描述 CID 128 卡标识号 RCA 16 相对卡地址（Relative Card Address）：本地系统中卡的地址，动态变化，在主机初始化的时候确定。SPI模式中没有 CSD 128 卡的描述数据：卡操作条件的相关的信息数据 SCR 64 SD配置寄存器：SD卡特定的信息数据 OCR 32 操作条件寄存器 CID 寄存器CID寄存器长度为16个字节的卡唯一标识号，该号在生产厂家编程后无法更改。 SD和MMC卡的CID寄存器结构不一样。 名称 类型 宽度 CID位 内容 CID值（例） 厂商ID Binary 8 [127:120] SD卡协会管理和分配 0x03 OEM/Application ID（OID） ASCII 16 [119:104] 识别卡的OEM或卡内容，由制造商分配 0x53, 0x44 产品名（PNM） ASCII 40 [103:64] 5个ASCII字符 SD128 产品版本（PRV） BCD 8 [65:56] 2个2进制编码的十进制数 30 序列号（PSN） Binary 32 [55:24] 32位无符号证书 保留 4 [23:20] 生产日期（MDT） BCD 12 [19:8] YYM（从2000年的偏移量） 0x014（Apr 2001） CRC7校验和（CRC） Binary 7 [7:1] 未用 1 [0:0] SD Bus Mode Pin# Nmae Type1 SD Description 1 CD/DAT3 I/O Card Detect / Data Line [Bit 3] 2 CMD I/O Cmmand / Response 3 VSS1 S Supply Voltage Ground 4 VDD S Supply Voltage 5 CLK I Clock 6 VSS2 S Supply Voltage Ground 7 DAT0 I/O Data Line [Bit 0] 8 DAT1 I/O Data Line [Bit 1] 9 DAT2 I/O Data Line [Bit 2] SPI Bus Mode 引脚定义 Pin# Nmae Type1 SPI Description 1 CS I Chip Select(Active Low) 2 MOSI I Host To Card 3 VSS1 S Supply Voltage Ground 4 VDD S Supply Voltage 5 CLK I Clock 6 VSS2 S Supply Voltage Ground 7 MISO O Card To Host 8 RSV I Reserved 9 RSV I Reserved SPI通信协议与命令SD卡的指令由6个字节组成。 字节1的最高两位固定为01, 低6位为命令号（例：CMD16为10000即0x10，完成的CMD16第一个字节为01010000）。 字节2～5为命令参数。 字节6的高7位为CRC值，最低位固定为1。]]></content>
      <categories>
        <category>单片机</category>
        <category>外设</category>
        <category>SD</category>
      </categories>
      <tags>
        <tag>SD</tag>
        <tag>SD卡</tag>
        <tag>SPI</tag>
        <tag>SDIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20. Ubuntu/Debian 安装ST-link的过程和方法]]></title>
    <url>%2F2018%2F07%2F23%2F20-Ubuntu-Debian-%E5%AE%89%E8%A3%85ST-link%E7%9A%84%E8%BF%87%E7%A8%8B%E5%92%8C%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[安装依赖1sudo apt install libusb-1.0-0-dev libusb-1.0-0 cmake build-essential 克隆stlink到本地目录12345678910111213141516171819202122232425262728293031323334353637$ git clone --depth=1 https://github.com/texane/stlink.git正克隆到 &#x27;stlink&#x27;...remote: Counting objects: 175, done.remote: Compressing objects: 100% (141/141), done.remote: Total 175 (delta 4), reused 101 (delta 2), pack-reused 0接收对象中: 100% (175/175), 198.33 KiB | 141.00 KiB/s, 完成.处理 delta 中: 100% (4/4), 完成.检查连接... 完成。$$ cd stlink$ ls -al总用量 116Kdrwxrwxr-x 15 hung hung 4.0K 7月 23 09:47 .drwxr-xr-x 9 hung hung 4.0K 7月 23 09:47 ..-rw-rw-r-- 1 hung hung 593 7月 23 09:47 .appveyor.yml-rw-rw-r-- 1 hung hung 7.2K 7月 23 09:47 ChangeLog.mddrwxrwxr-x 3 hung hung 4.0K 7月 23 09:47 cmake-rw-rw-r-- 1 hung hung 5.8K 7月 23 09:47 CMakeLists.txtdrwxrwxr-x 3 hung hung 4.0K 7月 23 09:47 debiandrwxrwxr-x 4 hung hung 4.0K 7月 23 09:47 docdrwxrwxr-x 4 hung hung 4.0K 7月 23 09:47 etcdrwxrwxr-x 2 hung hung 4.0K 7月 23 09:47 flashloadersdrwxrwxr-x 8 hung hung 4.0K 7月 23 09:48 .gitdrwxrwxr-x 2 hung hung 4.0K 7月 23 09:47 .github-rw-rw-r-- 1 hung hung 20 7月 23 09:47 .gitignoredrwxrwxr-x 3 hung hung 4.0K 7月 23 09:47 include-rw-rw-r-- 1 hung hung 1.7K 7月 23 09:47 LICENSE-rw-rw-r-- 1 hung hung 1.1K 7月 23 09:47 Makefile-rw-rw-r-- 1 hung hung 8.8K 7月 23 09:47 README.mddrwxrwxr-x 2 hung hung 4.0K 7月 23 09:47 scriptsdrwxrwxr-x 7 hung hung 4.0K 7月 23 09:47 srcdrwxrwxr-x 2 hung hung 4.0K 7月 23 09:47 stlinkv1_macosx_driverdrwxrwxr-x 2 hung hung 4.0K 7月 23 09:47 tests-rwxrwxr-x 1 hung hung 656 7月 23 09:47 .travis.sh-rw-rw-r-- 1 hung hung 348 7月 23 09:47 .travis.ymldrwxrwxr-x 3 hung hung 4.0K 7月 23 09:47 usr-rw-rw-r-- 1 hung hung 6 7月 23 09:47 .version 编译stlink12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364$ make-- The C compiler identification is GNU 5.4.0-- Check for working C compiler: /usr/bin/cc-- Check for working C compiler: /usr/bin/cc -- works-- Detecting C compiler ABI info-- Detecting C compiler ABI info - done-- Detecting C compile features-- Detecting C compile features - done-- stlink version: 79306cc-- Major Minor Patch-- Performing Test C_SUPPORTS_STD_GNU99-- Performing Test C_SUPPORTS_STD_GNU99 - Success-- Performing Test C_SUPPORTS_WALL-- Performing Test C_SUPPORTS_WALL - Success-- Performing Test C_SUPPORTS_WEXTRA-- Performing Test C_SUPPORTS_WEXTRA - Success-- Performing Test C_SUPPORTS_WSHADOW-- Performing Test C_SUPPORTS_WSHADOW - Success-- Performing Test C_SUPPORTS_D_FORTIFY_SOURCE_2-- Performing Test C_SUPPORTS_D_FORTIFY_SOURCE_2 - Success-- Performing Test C_SUPPORTS_FSTRICT_ALIASING-- Performing Test C_SUPPORTS_FSTRICT_ALIASING - Success-- Performing Test C_SUPPORTS_WUNDEF-- Performing Test C_SUPPORTS_WUNDEF - Success-- Performing Test C_SUPPORTS_WFORMAT-- Performing Test C_SUPPORTS_WFORMAT - Success-- Performing Test C_SUPPORTS_WFORMAT_SECURITY-- Performing Test C_SUPPORTS_WFORMAT_SECURITY - Success-- Performing Test C_SUPPORTS_WMAYBE_UNINITIALIZED-- Performing Test C_SUPPORTS_WMAYBE_UNINITIALIZED - Success-- Performing Test C_SUPPORTS_WMISSING_VARIABLE_DECLARATIONS-- Performing Test C_SUPPORTS_WMISSING_VARIABLE_DECLARATIONS - Failed-- Performing Test C_SUPPORTS_WSHORTEN_64_TO_32-- Performing Test C_SUPPORTS_WSHORTEN_64_TO_32 - Failed-- Performing Test C_SUPPORTS_WIMPLICIT_FUNCTION_DECLARATION-- Performing Test C_SUPPORTS_WIMPLICIT_FUNCTION_DECLARATION - Success-- Performing Test C_SUPPORTS_WREDUNDANT_DECLS-- Performing Test C_SUPPORTS_WREDUNDANT_DECLS - Success-- Performing Test C_SUPPORTS_FPIC-- Performing Test C_SUPPORTS_FPIC - Success-- Performing Test C_SUPPORTS_O2-- Performing Test C_SUPPORTS_O2 - Success-- Performing Test C_SUPPORTS_WERROR-- Performing Test C_SUPPORTS_WERROR - Success-- Found Libusb: /usr/lib/x86_64-linux-gnu/libusb-1.0.so-- found USB-- Found PkgConfig: /usr/bin/pkg-config (found version &quot;0.29.1&quot;)-- Checking for module &#x27;gtk+-3.0&#x27;-- Found gtk+-3.0, version 3.18.9-- Looking for sys/mman.h-- Looking for sys/mman.h - found-- Looking for unistd.h-- Looking for unistd.h - foundCMake Error at CMakeLists.txt:121 (set_target_properties): set_target_properties called with incorrect number of arguments.-- Manpage generation disabled-- Debian-based Linux OS detected-- Configuring incomplete, errors occurred!See also &quot;/home/hung/Temp/stlink/build/Release/CMakeFiles/CMakeOutput.log&quot;.See also &quot;/home/hung/Temp/stlink/build/Release/CMakeFiles/CMakeError.log&quot;.Makefile:42: recipe for target &#x27;build/Release&#x27; failedmake: *** [build/Release] Error 1 上述错误的解决办法是删除.git目录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115$ rm -rf .git$ make clean$ make-- The C compiler identification is GNU 5.4.0-- Check for working C compiler: /usr/bin/cc-- Check for working C compiler: /usr/bin/cc -- works-- Detecting C compiler ABI info-- Detecting C compiler ABI info - done-- Detecting C compile features-- Detecting C compile features - done-- stlink version: 1.5.0-- Major 1 Minor 5 Patch 0-- Performing Test C_SUPPORTS_STD_GNU99-- Performing Test C_SUPPORTS_STD_GNU99 - Success-- Performing Test C_SUPPORTS_WALL-- Performing Test C_SUPPORTS_WALL - Success-- Performing Test C_SUPPORTS_WEXTRA-- Performing Test C_SUPPORTS_WEXTRA - Success-- Performing Test C_SUPPORTS_WSHADOW-- Performing Test C_SUPPORTS_WSHADOW - Success-- Performing Test C_SUPPORTS_D_FORTIFY_SOURCE_2-- Performing Test C_SUPPORTS_D_FORTIFY_SOURCE_2 - Success-- Performing Test C_SUPPORTS_FSTRICT_ALIASING-- Performing Test C_SUPPORTS_FSTRICT_ALIASING - Success-- Performing Test C_SUPPORTS_WUNDEF-- Performing Test C_SUPPORTS_WUNDEF - Success-- Performing Test C_SUPPORTS_WFORMAT-- Performing Test C_SUPPORTS_WFORMAT - Success-- Performing Test C_SUPPORTS_WFORMAT_SECURITY-- Performing Test C_SUPPORTS_WFORMAT_SECURITY - Success-- Performing Test C_SUPPORTS_WMAYBE_UNINITIALIZED-- Performing Test C_SUPPORTS_WMAYBE_UNINITIALIZED - Success-- Performing Test C_SUPPORTS_WMISSING_VARIABLE_DECLARATIONS-- Performing Test C_SUPPORTS_WMISSING_VARIABLE_DECLARATIONS - Failed-- Performing Test C_SUPPORTS_WSHORTEN_64_TO_32-- Performing Test C_SUPPORTS_WSHORTEN_64_TO_32 - Failed-- Performing Test C_SUPPORTS_WIMPLICIT_FUNCTION_DECLARATION-- Performing Test C_SUPPORTS_WIMPLICIT_FUNCTION_DECLARATION - Success-- Performing Test C_SUPPORTS_WREDUNDANT_DECLS-- Performing Test C_SUPPORTS_WREDUNDANT_DECLS - Success-- Performing Test C_SUPPORTS_FPIC-- Performing Test C_SUPPORTS_FPIC - Success-- Performing Test C_SUPPORTS_O2-- Performing Test C_SUPPORTS_O2 - Success-- Performing Test C_SUPPORTS_WERROR-- Performing Test C_SUPPORTS_WERROR - Success-- Found Libusb: /usr/lib/x86_64-linux-gnu/libusb-1.0.so-- found USB-- Found PkgConfig: /usr/bin/pkg-config (found version &quot;0.29.1&quot;)-- Checking for module &#x27;gtk+-3.0&#x27;-- Found gtk+-3.0, version 3.18.9-- Looking for sys/mman.h-- Looking for sys/mman.h - found-- Looking for unistd.h-- Looking for unistd.h - found-- Manpage generation disabled-- Debian-based Linux OS detected-- Configuring done-- Generating done-- Build files have been written to: /home/hung/Temp/stlink/build/Release[RELEASE]Scanning dependencies of target stlink-static[ 2%] Building C object CMakeFiles/stlink-static.dir/src/chipid.c.o[ 5%] Building C object CMakeFiles/stlink-static.dir/src/common.c.o[ 8%] Building C object CMakeFiles/stlink-static.dir/src/usb.c.o[ 11%] Building C object CMakeFiles/stlink-static.dir/src/sg.c.o[ 14%] Building C object CMakeFiles/stlink-static.dir/src/logging.c.o[ 17%] Building C object CMakeFiles/stlink-static.dir/src/flash_loader.c.o[ 20%] Linking C static library libstlink.a[ 20%] Built target stlink-staticScanning dependencies of target stlink[ 23%] Building C object CMakeFiles/stlink.dir/src/chipid.c.o[ 26%] Building C object CMakeFiles/stlink.dir/src/common.c.o[ 29%] Building C object CMakeFiles/stlink.dir/src/usb.c.o[ 32%] Building C object CMakeFiles/stlink.dir/src/sg.c.o[ 35%] Building C object CMakeFiles/stlink.dir/src/logging.c.o[ 38%] Building C object CMakeFiles/stlink.dir/src/flash_loader.c.o[ 41%] Linking C shared library libstlink.so[ 41%] Built target stlinkScanning dependencies of target st-flash[ 44%] Building C object CMakeFiles/st-flash.dir/src/tools/flash.c.o[ 47%] Building C object CMakeFiles/st-flash.dir/src/tools/flash_opts.c.o[ 50%] Linking C executable st-flash[ 50%] Built target st-flashScanning dependencies of target st-info[ 52%] Building C object CMakeFiles/st-info.dir/src/tools/info.c.o[ 55%] Linking C executable st-info[ 55%] Built target st-infoScanning dependencies of target st-util[ 58%] Building C object src/gdbserver/CMakeFiles/st-util.dir/gdb-remote.c.o[ 61%] Building C object src/gdbserver/CMakeFiles/st-util.dir/gdb-server.c.o[ 64%] Building C object src/gdbserver/CMakeFiles/st-util.dir/semihosting.c.o[ 67%] Linking C executable st-util[ 67%] Built target st-utilScanning dependencies of target stlink-gui-local[ 70%] Building C object src/tools/gui/CMakeFiles/stlink-gui-local.dir/stlink-gui.c.o[ 73%] Linking C executable stlink-gui-local[ 73%] Built target stlink-gui-localScanning dependencies of target stlink-gui[ 76%] Building C object src/tools/gui/CMakeFiles/stlink-gui.dir/stlink-gui.c.o[ 79%] Linking C executable stlink-gui[ 79%] Built target stlink-guiScanning dependencies of target sg[ 82%] Building C object tests/CMakeFiles/sg.dir/sg.c.o[ 85%] Linking C executable sg[ 85%] Built target sgScanning dependencies of target usb[ 88%] Building C object tests/CMakeFiles/usb.dir/usb.c.o[ 91%] Linking C executable usb[ 91%] Built target usbScanning dependencies of target flash[ 94%] Building C object tests/CMakeFiles/flash.dir/flash.c.o[ 97%] Building C object tests/CMakeFiles/flash.dir/__/src/tools/flash_opts.c.o[100%] Linking C executable flash[100%] Built target flash 安装stlink123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293$ cd build/Release$ ls -al总用量 352drwxrwxr-x 8 hung hung 4096 7月 23 09:52 .drwxrwxr-x 3 hung hung 4096 7月 23 09:51 ..-rw-rw-r-- 1 hung hung 19316 7月 23 09:51 CMakeCache.txtdrwxrwxr-x 8 hung hung 4096 7月 23 09:52 CMakeFiles-rw-rw-r-- 1 hung hung 7490 7月 23 09:51 cmake_install.cmake-rw-r--r-- 1 hung hung 3447 7月 23 09:51 CPackConfig.cmake-rw-r--r-- 1 hung hung 3850 7月 23 09:51 CPackSourceConfig.cmakedrwxrwxr-x 3 hung hung 4096 7月 23 09:51 docdrwxrwxr-x 4 hung hung 4096 7月 23 09:51 include-rw-rw-r-- 1 hung hung 132872 7月 23 09:52 libstlink.alrwxrwxrwx 1 hung hung 14 7月 23 09:52 libstlink.so -&gt; libstlink.so.1lrwxrwxrwx 1 hung hung 18 7月 23 09:52 libstlink.so.1 -&gt; libstlink.so.1.5.0-rwxrwxr-x 1 hung hung 96312 7月 23 09:52 libstlink.so.1.5.0-rw-rw-r-- 1 hung hung 18977 7月 23 09:51 Makefiledrwxrwxr-x 4 hung hung 4096 7月 23 09:51 src-rwxrwxr-x 1 hung hung 18528 7月 23 09:52 st-flash-rwxrwxr-x 1 hung hung 13480 7月 23 09:52 st-infodrwxrwxr-x 3 hung hung 4096 7月 23 09:52 testsdrwxrwxr-x 3 hung hung 4096 7月 23 09:51 usr$ make[ 20%] Built target stlink-static[ 41%] Built target stlink[ 50%] Built target st-flash[ 55%] Built target st-info[ 67%] Built target st-util[ 73%] Built target stlink-gui-local[ 79%] Built target stlink-gui[ 85%] Built target sg[ 91%] Built target usb[100%] Built target flash$ sudo make install[sudo] hung 的密码：[ 20%] Built target stlink-static[ 41%] Built target stlink[ 50%] Built target st-flash[ 55%] Built target st-info[ 67%] Built target st-util[ 73%] Built target stlink-gui-local[ 79%] Built target stlink-gui[ 85%] Built target sg[ 91%] Built target usb[100%] Built target flashInstall the project...-- Install configuration: &quot;Release&quot;-- Installing: /usr/local/lib/libstlink.so.1.5.0-- Up-to-date: /usr/local/lib/libstlink.so.1-- Up-to-date: /usr/local/lib/libstlink.so-- Installing: /usr/local/lib/libstlink.a-- Installing: /usr/local/bin/st-flash-- Set runtime path of &quot;/usr/local/bin/st-flash&quot; to &quot;&quot;-- Installing: /usr/local/bin/st-info-- Set runtime path of &quot;/usr/local/bin/st-info&quot; to &quot;&quot;-- Installing: /etc/modprobe.d/stlink_v1.conf-- Installing: /etc/udev/rules.d/49-stlinkv1.rules-- Installing: /etc/udev/rules.d/49-stlinkv2-1.rules-- Installing: /etc/udev/rules.d/49-stlinkv2.rules-- Installing: /usr/local/bin/st-util-- Set runtime path of &quot;/usr/local/bin/st-util&quot; to &quot;&quot;-- Installing: /usr/local/bin/stlink-gui-- Installing: /usr/local/share/stlink/stlink-gui.ui-- Installing: /usr/local/share/applications/stlink-gui.desktop-- Installing: /usr/local/share/icons/hicolor/scalable/apps/stlink-gui.svg-- Installing: /usr/local/lib/pkgconfig/stlink.pc-- Installing: /usr/local/include/stlink.h-- Installing: /usr/local/include/stlink/commands.h-- Installing: /usr/local/include/stlink/flash_loader.h-- Installing: /usr/local/include/stlink/mmap.h-- Installing: /usr/local/include/stlink/sg.h-- Installing: /usr/local/include/stlink/usb.h-- Installing: /usr/local/include/stlink/backend.h-- Installing: /usr/local/include/stlink/reg.h-- Installing: /usr/local/include/stlink/chipid.h-- Installing: /usr/local/include/stlink/logging.h-- Installing: /usr/local/include/stlink/version.h-- Installing: /usr/local/share/man/man1/st-util.1-- Installing: /usr/local/share/man/man1/st-flash.1-- Installing: /usr/local/share/man/man1/st-info.1$ which st-flash/usr/local/bin/st-flash$ st-flash --versionst-flash: error while loading shared libraries: libstlink.so.1: cannot open shared object file: No such file or directory$ ldd /usr/local/bin/st-flash linux-vdso.so.1 =&gt; (0x00007fffc0ad0000) libstlink.so.1 =&gt; not found libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f68856c0000) libusb-1.0.so.0 =&gt; /lib/x86_64-linux-gnu/libusb-1.0.so.0 (0x00007f68854a8000) /lib64/ld-linux-x86-64.so.2 (0x00007f6885c9f000) libudev.so.1 =&gt; /lib/x86_64-linux-gnu/libudev.so.1 (0x00007f6885e7a000) libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f688528b000) librt.so.1 =&gt; /lib/x86_64-linux-gnu/librt.so.1 (0x00007f6885083000) 如果遇到上述错误，可以执行sudo ldconfig解决 1234567891011$ ldd /usr/local/bin/st-flash linux-vdso.so.1 =&gt; (0x00007ffdb1bdb000) libstlink.so.1 =&gt; /usr/local/lib/libstlink.so.1 (0x00007f4580cf6000) libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f458092c000) libusb-1.0.so.0 =&gt; /lib/x86_64-linux-gnu/libusb-1.0.so.0 (0x00007f4580714000) /lib64/ld-linux-x86-64.so.2 (0x00007f4580f0b000) libudev.so.1 =&gt; /lib/x86_64-linux-gnu/libudev.so.1 (0x00007f45810e6000) libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f45804f7000) librt.so.1 =&gt; /lib/x86_64-linux-gnu/librt.so.1 (0x00007f45802ef000)$ st-flash --versionv1.5.0]]></content>
      <categories>
        <category>Linux</category>
        <category>Debian</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>ST-link</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19. digispark由于权限导致错误Assertion res >= 4 failed的解决方法]]></title>
    <url>%2F2018%2F07%2F12%2F19-digispark%E7%94%B1%E4%BA%8E%E6%9D%83%E9%99%90%E5%AF%BC%E8%87%B4%E9%94%99%E8%AF%AFAssertion-res-4-failed%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[错误提示1micronucleus: library/micronucleus_lib.c:66: micronucleus_connect: Assertion `res &gt;= 4&#x27; failed. 解决方法创建文件/etc/udev/rules.d/digispark.rules，并写入以下内容 1SUBSYSTEM==&quot;usb&quot;, ATTR&#123;idVendor&#125;==&quot;16d0&quot;, ATTR&#123;idProduct&#125;==&quot;0753&quot;, MODE=&quot;0660&quot;, GROUP=&quot;dialout&quot; 确保用户在dialout组，否则执行sudo usermod -aG dialout &#123; username &#125;]]></content>
      <categories>
        <category>单片机</category>
        <category>Arduino</category>
        <category>Digispark</category>
      </categories>
      <tags>
        <tag>Arduino</tag>
        <tag>Digispark</tag>
        <tag>USB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18. FreeBSD配置网络的方法]]></title>
    <url>%2F2018%2F06%2F04%2F18-FreeBSD%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[配置IP 编辑/etc/rc.conf文件/etc/rc.conf1234567hostname=&quot;freebsd&quot;ifconfig_em0=&quot;inet 192.168.1.201 netmask 255.255.255.0&quot;defaultrouter=&quot;192.168.1.1&quot;sshd_enable=&quot;YES&quot;# Set dumpdev to &quot;AUTO&quot; to enable crach dumps, &quot;NO&quot; to disbaledumpdev=&quot;AUTO&quot; 执行reboot重启或者执行sh /etc/rc.conf生效 配置DNS服务器 编辑/etc/resolv.conf 填写或更改一下内容/etc/resolv.conf1nameserver 192.168.1.1]]></content>
      <categories>
        <category>BSD</category>
        <category>FreeBSD</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>FreeBSD</tag>
        <tag>网络配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[17. 如何在Linux上使用STM8单片机]]></title>
    <url>%2F2018%2F05%2F24%2F17-%E5%A6%82%E4%BD%95%E5%9C%A8Linux%E4%B8%8A%E4%BD%BF%E7%94%A8STM8%E5%8D%95%E7%89%87%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[在上一篇文章中，我们看了一下廉价的STM8开发板和编程使用的ST-Link。现在是时候采取一些行动了！ 环境配置实例程序和文档先阅读一些资料是一个良好的开端。 ST提供大量关于STM8S103F3的免费资料，该页面还列出了微控制器的所有主要功能，如果你想看的话。 如果你按照我的步骤开始的话，我推荐你另外阅读一下SDCC的用户手册，以便了了解SDCC编译器的特殊语法。 编程软件本指南是为Arch Linux编写的，其他发行版的用户可能会发现某些指令不能运行，请根据需要调整 在Linux上开发STM8单片机需要下面两个软件的配合： stm8flash 一个用于链接ST-Link的软件适配器 sdcc 一个编译器 ST还提供了一些其他为STM8编程的编译器或工具， 但是他们只可以运行在windows上，或许你可以通过wine软件来运行，但是这都不是一个好办法。 如果你还打算使用ST-Link对STM32进行开发，你应该还需要安装community/stlink 您可能需要也可能不需要以下内容/etc/udev/rules.d/49-stlinkv2.rules， 我忘记了这是从哪里复制回来的了 123456789101112131415161718192021222324252627282930313233# stm32 discovery boards, with onboard st/linkv2# ie, STM32L, STM32F4.# STM32VL has st/linkv1, which is quite differentSUBSYSTEMS==&quot;usb&quot;, ATTRS&#123;idVendor&#125;==&quot;0483&quot;, ATTRS&#123;idProduct&#125;==&quot;3748&quot;, \ MODE:=&quot;0666&quot;, \ SYMLINK+=&quot;stlinkv2_%n&quot;SUBSYSTEMS==&quot;usb&quot;, ATTRS&#123;idVendor&#125;==&quot;0483&quot;, ATTRS&#123;idProduct&#125;==&quot;374b&quot;, \ KERNEL!=&quot;sd*&quot;, KERNEL!=&quot;sg*&quot;, KERNEL!=&quot;tty*&quot;, SUBSYSTEM!=&quot;bsg&quot;, \ MODE:=&quot;0666&quot;, \ SYMLINK+=&quot;stlinkv2_%n&quot;SUBSYSTEMS==&quot;usb&quot;, ATTRS&#123;idVendor&#125;==&quot;0483&quot;, ATTRS&#123;idProduct&#125;==&quot;374b&quot;, \ KERNEL==&quot;sd*&quot;, MODE:=&quot;0666&quot;, \ SYMLINK+=&quot;stlinkv2_disk&quot;SUBSYSTEMS==&quot;usb&quot;, ATTRS&#123;idVendor&#125;==&quot;0483&quot;, ATTRS&#123;idProduct&#125;==&quot;374b&quot;, \ KERNEL==&quot;sg*&quot;, MODE:=&quot;0666&quot;, \ SYMLINK+=&quot;stlinkv2_raw_scsi&quot;SUBSYSTEMS==&quot;usb&quot;, ATTRS&#123;idVendor&#125;==&quot;0483&quot;, ATTRS&#123;idProduct&#125;==&quot;374b&quot;, \ SUBSYSTEM==&quot;bsg&quot;, MODE:=&quot;0666&quot;, \ SYMLINK+=&quot;stlinkv2_block_scsi&quot;SUBSYSTEMS==&quot;usb&quot;, ATTRS&#123;idVendor&#125;==&quot;0483&quot;, ATTRS&#123;idProduct&#125;==&quot;374b&quot;, \ KERNEL==&quot;tty*&quot;, MODE:=&quot;0666&quot;, \ SYMLINK+=&quot;stlinkv2_console&quot;# If you share your linux system with other users, or just don&#x27;t like the# idea of write permission for everybody, you can replace MODE:=&quot;0666&quot; with# OWNER:=&quot;yourusername&quot; to create the device owned by you, or with# GROUP:=&quot;somegroupname&quot; and control access using standard unix groups. 库文件SDCC支持STM8，但由于许可原因(booo, ST!)，标准外设库（SPL）是缺失的。 有人开发了一个使SPL与SDCC兼容的补丁，点击这里 (这个补丁已经过期了，点击这里查看另一个更新的)， 另外有一个AUR软件包试(aur/stm8-spl-sdcc)图将其安装在SDCC库文件夹中, 但是这些SPL的文件包具有登录和EULA点击保护(but alas the zip with the SPL files is login &amp; EULA-click protected)(booo again, ST!)。 构建这个软件包的任务非常艰巨！ 下载SPL首先，你必须从ST的官网(the evil corporate’s claws)下载SPL包的zip文件。 点击这里 我为此做了一个图片向导： 打补丁在你下载了SPL的压缩包之后，为了让他能在SDCC下使用，我们需要给它打补丁，因为它是为非自由编译器（如Cosmic）制作的。 虽然通过电子邮件的请求可能可以免费获取Cosmic，但是它只能在windows上使用。 让我们开始打补丁吧： 下载AUR软件包，可能使用cower -d stm8-spl-sdcc 将来之不易的en.stsw-stm8069.zip放到PKGBUILD同级，然后重新命名为stsw-stm8069.zip，HASH应该匹配 先运行mapekpg，接下来再运行sudo pacman -U &lt;the xz file&gt; 非Arch用户可以手动应用这些修补程序 如果你不喜欢在系统目录中安装这样的东西，你可以简单地从src/STM8S_StdPeriph_Lib复制修补后的SPL， 然后放到你认为合适的地方（或者直接将libraries/STM8S_StdPeriph_Driver放到你的项目中去）。 您还可以从src/STM8S_StdPeriph_Lib/Project/STM8S_StdPeriph_Template/SDCC中获取示例Makefile， 虽然需要一些调整，但是还是有一些参考价值。 开始你的第一个项目在此之前，你应该已经准备好工作环境，并且有一个最小系统开发板。 你可以点击这个链接下载实例程序，或者直接下载已经编译好的ihx文件，前提是你有和我一样的开发板，否则你可能不能直接使用。 接下来调整makefile里面的SPL路径，然后运行make命令 12345$ makesdcc -mstm8 -lstm8 --opt-code-size -DSTM8S103 -I./src -I/usr/share/sdcc/include/stm8/ -DSKIP_TRAPS=0 -c ./src/stm8s_it.c -o STM8S103/stm8s_it.relsdcc -mstm8 -lstm8 --opt-code-size -DSTM8S103 -I./src -I/usr/share/sdcc/include/stm8/ -DSKIP_TRAPS=0 -c ./src/main.c -o STM8S103/main.relsdcc -mstm8 -lstm8 --opt-code-size -DSTM8S103 -I./src -I/usr/share/sdcc/include/stm8/ -DSKIP_TRAPS=0 -c /usr/share/sdcc/lib/src/stm8/stm8s_gpio.c -o STM8S103/stm8s_gpio.relsdcc -mstm8 -lstm8 --opt-code-size -o ./STM8S103/STM8S103.hex STM8S103/stm8s_it.rel STM8S103/main.rel STM8S103/stm8s_gpio.rel 之所以makefile里面定一个多个步骤，是因为sdcc无法同时编译多文件。 首先我们需要将每个.c文件编译到.rel文件(类似于.o文件，不过这是sdcc的版本), 然后我们再通过这些.rel文件生成二进制文件。 组织化你的代码目前我们的源文件看起来很混乱，大部分原因是因为过多的注释，但是幸好main.c文件里面还算清晰， 我们的项目基于ST提供的原始项目模板，这也是大部分注释的来源。同样的，STM32也有类似的问题， 你可以随意清理。 你也可以将SPL的库文件直接复制到你的项目中，然后进行整理–删除里面的废话。 (you should be able to simply #define it as no-op in stm8s.h, then you save some FLASH bytes by removing the error messages) 现在你可以直接阅读SPL的源代码了，以便从中获取更多你感兴趣的内容。 这些文件通过外设的类型分组，像SPI、IIC、UART等等。 此外，SPL的库文件夹中还有一个大小为6M的chm说明文档，如果你找到办法打开它，它会很有用的。 如果你选择使用SDCC，你可能会因为它缺少-Wl,--gc-sections等功能而不愉快。 它总是将整个库文件与代码捆绑在一起，尽管某些函数显然未被使用。 作为一个解决小文件大小的方法，我把几乎所有的SPL转换成内联函数， 转换过后的代码可以在这里下载， 不过我只做了简单的测试。 烧写程序每个最小系统板在出场之前，都会预先安装一个blink闪烁程序， 所以你可以直接插上电源就可以看到它开始工作。 现在你可以链接你的ST-Link开始烧写程序了， 不要在使用USB供电的时候同时接通ST-LINK的3.3v到开发板，这有可能会烧坏你的烧写器 烧写的第一步是关闭写保护，因为出厂加载的固件是读保护的，在锁定时你无法做任何事情。 要解锁芯片，请执行下面的命令(运行stm8flash -h查看帮助) 1234stm8flash -c stlinkv2 -p stm8s103f3 -uDetermine OPT areaUnlocked device. Option bytes reset to default state.Bytes written: 11 板子此时应该会停止闪烁，不好，你现在把它变成砖了， 不过不用担心，我们马上为它烧写新的程序。 接下来执行make flash命令开始烧写你的程序 1234$ stm8flash -c stlinkv2 -p stm8s103f3 -s flash -w stm8_blinky.hexDetermine FLASH areaWriting Intel hex file 655 bytes at 0x8000... OKBytes written: 655 此时开发板会立即开始闪烁，你可以通过更改演示观察执行效果，OK，It’s your time now! 最后的想法真心希望这两篇关于STM8的介绍可以帮助到你！ 你现在已经学会的搭建环境和烧写程序，现在尽情发挥你的创意吧！ 我打算花一些时间玩STM8单片机，后续可能还会发表一些自己的想法， Until then, happy hacking! 声明这篇文章是译文，原文地址点击这里，原作者是Ondřej Hruška。 此译文已获取原作者邮件授权，请仅用于学习用途，不允许转载，谢谢合作！]]></content>
      <categories>
        <category>单片机</category>
        <category>stm8</category>
      </categories>
      <tags>
        <tag>stm8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[16. STM8单片机介绍]]></title>
    <url>%2F2018%2F05%2F23%2F16-STM8%E5%8D%95%E7%89%87%E6%9C%BA%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[什么是STM8微控制器STM8是一款意法半导体制造的高性价比、低功耗的8位微控制器。在简单的应用中，可以取代Arduino或者ATMEGA。 8位微控制器已经存在很长一段时间了，随着更加强大的芯片普及，8位微控制器渐渐不再成为大家的焦点， 但是，8位的微控制器一直没有完全离开我们的视野。 像臭名昭著的8051,到目前为止它仍然非常活跃，部分原因可能是因为它的版权已经过期， 现在任何人都可以免费使用它或者是融入到自己的产品中去（像国内的STC）。 多年以来出现过很多类型的其他8位微控制器家族，但是8位微控制器真正的繁荣是伴随着Arduino的推出和整个黑客DIY热潮。 毫无疑问你一定熟知Atmel的AVR系列或者Microchip的PIC系列， 由Arduino项目推广的AVR系列或者PIC已经逐渐占据了业余爱好者的市场， 并且已经形成了成熟的商业产品，你可以在购物网站（原文eBay）上搜索Arduino模块试试看！ 随着这种现象，毫无疑问其他芯片制造商自然想分一倍羹，意法半导体的STM8系列就是其中的一员。 你可能已经知道该公司是一家通用半导体制造商，并且它们之前推出过非常流行的STM32系列。 虽然STM8还没有成为主流，但是不论如何，它非常便宜并且使用广泛。 还有一些STM8的变体用于汽车电子，但是这是不我们接下来关注的系列。 STM8 vs ATMEGA328P 功能比较 Arduino系列主要基于AVR，像ATMEGA328P，它运行在16MHz的晶震上， 具有32kB的FLASH、2kB的RAM和一些必要的外设接口像定时器、串口、SPI、IIC等等。 STM8我们以STM8S103F3为例，它具有ATMEGA328P类似的外设，但是内存空间要小得多（8kB FLASH, 1kB RAM）。 虽然它无法完全取代ATMEGA，但是在很多时候，因为它成本低所以使很多高性价比的产品成为现实， 60美分做一个SPI to Neopixel，没问题！ 架构差异 ATMEGA的架构中有一个令人不快的缺陷： the Harvard memory design（哈佛内存设计）。 FLASH和RAM以重叠的方式共享相同的地址空间，这也许是为了节省地址位(address bit)， 导致了相同的地址可能是FLASH或者RAM二者之一。这就是导致烦人的pgm_read_byte()原因—— 它需要一个特殊的汇编指令LPM从FLASH读取数据，甚至连avr-gcc的高层抽象都没有解决这个问题， 并且在使用EEPROM的时候也会面临同样的问题。不过这并不致命，因为我们不会经常这样做。 可能受STM32启发的，STM8显示为冯诺依曼。因为两个存储器映射到了一个线性地址空间，没有重叠。 内部有两条总线，但它的处理是透明的。 因此，您可以无缝地将常量存储在程序存储器中，甚至可以从RAM运行代码。 这个优势可能不是game changer(规则改变者)，但它对调试有帮助（如果您使用专有的Windows IDE）。 最小系统板下面是我使用的开发板的功能图，它搭载STM8S103F3P6芯片 它的体积非常小，类似Arduino Pro Mini。 注意不要被上面的USB接口欺骗了，它并没有USB接口，也没有板载下载器，只能用来供电。 虽然有虚拟USB的可能性，但该板没有必要的12MHz晶振，并且DP/DM引脚(USB的引脚)也很难接入。 不过并不是说这个想法不值得一试！ 这是板子的顶部和底部的实际照片 关于供电从板子的背面我们可以看到板载的3.3v降压芯片，我们可以通过5V那个引脚供电，也可以通过USB接口供电， 可惜的是USB的数据线被悬空了。 5V输出脚和3.3V输出脚都可以用作外设供电，但是需要注意的是，5V引脚直接与电源相连，并没有5V稳压， 如果你使用USB供电，可以得到一个近似5V的电压，否则需要自己链接5V稳压。 如果您打算从3.3V输出引脚驱动比较耗电的东西，请记住稳压器上没有散热器， 所以如果使用较高的输入电压或过高的电流，它很容易变热。 对于Neopixels等比较耗电的设备，我建议您直接将它们连接到5V引脚（如果您使用USB供电板）。 还有一种供电的方法，就是通过编程器(STLink)供电，但是请非常注意，不要在使用比较耗电的外设的情况下使用编程器供电， STLink里面只有一个非常小的电流调节器，非常易损坏。 板载LED最小系统板上有两个LED，一个是电源指示灯，另一个链接到B5。新买的板子会内置一个blink测试程序， 我们可以使用USB供电查看新买的板子是否正常工作。 编程设备要给STM8单片机烧写程序，你必须有一个支持SWIM接口的ST-Link编程器，ST-Link同时可以给STM32烧写程序， 如果以后STM8满足不了你的需求，你也可以使用它烧写STM32。 声明这篇文章是译文，原文地址点击这里，原作者是Ondřej Hruška。 此译文已获取原作者邮件授权，请仅用于学习用途，不允许转载，谢谢合作！]]></content>
      <categories>
        <category>单片机</category>
        <category>STM8</category>
      </categories>
      <tags>
        <tag>STM8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[15. 51单片机的定时计数器]]></title>
    <url>%2F2018%2F05%2F22%2F15-51%E5%8D%95%E7%89%87%E6%9C%BA%E7%9A%84%E5%AE%9A%E6%97%B6%E8%AE%A1%E6%95%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[介绍8051微控制器具有timer0和timer1两个定时计数器。使用定时计数器可以独立于单片机内部程序产生一个延时或用于计数。两个定时计数器都是16位宽的，因为8051单片机是8位架构，所以每个16位定时器分别由两个单独的8位寄存器构成。 STC89C52的文档上面说有3个16位定时器，不过这里以传统mcs-51为准 主要寄存器的作用 寄存器 地址 作用 TL0 0x8A 定时器0低8位寄存器 TL1 0x8B 定时器1低8位寄存器 TH0 0x8C 定时器0高8位寄存器 TH1 0x8D 定时器1高8位寄存器 TCON 0x88 定时器控制寄存器 TMOD 0x89 定时器工作方式寄存器 TL0 TH0 TL1 TH1TH0 和 TL0 组合成timer0 16位定时器; TH1 和 TL1 组合成timer1 16位定时器 .table-text-center { th, td { text-align: center; } } 76543210 76543210 TH0 TL0 TCON 寄存器 7 6 5 4 3 2 1 0 TF1 TR1 TF0 TR0 IE1 IT1 IE0 IT0 123456789/* TCON */__sbit __at (0x88) IT0 ;__sbit __at (0x89) IE0 ;__sbit __at (0x8A) IT1 ;__sbit __at (0x8B) IE1 ;__sbit __at (0x8C) TR0 ;__sbit __at (0x8D) TF0 ;__sbit __at (0x8E) TR1 ;__sbit __at (0x8F) TF1 ; TMOD 寄存器 7 6 5 4 3 2 1 0 T1_GATE T1_CT T1_M1 T1_M0 T0_GATE T0_CT T0_M1 T0_M0 12345678910/* BIT definitions for bits that are not directly accessible *//* TMOD bits */#define T0_M0 0x01#define T0_M1 0x02#define T0_CT 0x04#define T0_GATE 0x08#define T1_M0 0x10#define T1_M1 0x20#define T1_CT 0x40#define T1_GATE 0x80 定时器的工作模式 M1 M0 模式 说明 0 0 0 13位定时器/计数器, TL只使用低5位 0 1 1 16位定时器/计数器 1 0 2 8位定时器/计数器,可以自动装初值 1 1 3 T0分成单独两个8位计时器,此时T1不工作 最大值和初值计算方法此处以11.0592MHz晶震、定时器工作方式1为例 类别 计算方法 最大值 65536 * 12 / 11.0592 = 71111us 50ms初值 65536 - 50000 / (12 / 11.0592) = 19456 = 4C00H 示例程序1234567891011121314151617181920212223242526272829303132333435363738#include &lt;mcs51/8051.h&gt;unsigned char count = 0;void setup()&#123; // set timer 0 mode 1 TMOD = 0x01; TH0 = 0x4C; TL0 = 0x00; // start timer 0 TR0 = 1; // enable timer 0 interrupt ET0 = 1; // enable all interrupt EA = 1;&#125;void loop()&#123; if(count == 20) P0_0 = !P0_0;&#125;void main()&#123; setup(); while(1) loop();&#125;void timer0() __interrupt 1&#123; TH0 = 0x4C; TL0 = 0x00; count++; if(count &gt; 20) count = 0;&#125;]]></content>
      <categories>
        <category>单片机</category>
        <category>51单片机</category>
      </categories>
      <tags>
        <tag>定时器</tag>
        <tag>timer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[14. 在linux下给51单片机写程序]]></title>
    <url>%2F2018%2F05%2F19%2F14-%E5%9C%A8linux%E4%B8%8B%E7%BB%9951%E5%8D%95%E7%89%87%E6%9C%BA%E5%86%99%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[需要使用到的软件 sdcc SDCC (Small Device C Compiler)是一个优化的嵌入式ANSI C编译器，它支持的平台包括是英特尔8051、美信80DS390、Zilog Z80、摩托罗拉68HC08和微芯的PIC16及PIC18系列。 SDCC是自由开放源码软件，依照GNU通用公共许可证（GPL）分发。 具体支持的芯片列表: mcs51、z80、z180、r2k、r3ka、gbz80、tlcs90、ds390、pic16、pic14、TININative、ds400、hc08、s08、stm8 stcflash 使用python编写的一个开源跨平台的stc单片机烧写工具 步骤 安装sdcc与stcflash sdcc可以使用包管理器安装或通过源码安装。 1sudo apt install sdcc stcflash可以中github直接下载到本地，加入环境变量即可。 12345wget https://github.com/laborer/stcflash/archive/master.zipunzip stcflash-master.zipcd stcflash-mastermv stcflash.py stcflashsudo mv stcflash /usr/local/bin 然后安装stcflash的依赖包 1sudo apt install python-serial 使用sdcc风格的C语言编写程序，例如 123456789101112#include &lt;mcs51/8051.h&gt;void main()&#123; __bit status = 1; while(1) &#123; P0_0 = status; status = !status; delay(1000); &#125;&#125; 需要注意的是: sdcc中所有非C标准关键字都以两个下划线开头 单个引脚的表示使用下划线表示，例如P3_2，与keil的^不同 引用的头文件为mcs51/8051.h 编译程序和生成hex文件 1sdcc main.c -o main.ihx sdcc编译之后直接得到的是ihx文件，并不是51单片机需要的hex文件，所以需要使用packihx命令打包。 packihx命令是在安装sdcc的时候附带安装的，所以可以直接使用。 1packihx main.ihx &gt; main.hex 烧写程序到单片机 1sudo stcflash --port /dev/ttyUSB0 main.hex 烧写的时候需要重新给单片机上电]]></content>
      <categories>
        <category>单片机</category>
        <category>51单片机</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>sdcc</tag>
        <tag>stcflash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[13. 基于网页的室温监控系统]]></title>
    <url>%2F2018%2F05%2F16%2F13-%E5%9F%BA%E4%BA%8E%E7%BD%91%E9%A1%B5%E7%9A%84%E5%AE%A4%E6%B8%A9%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[简介周末使用 ds18b20 做了一个温度检测的装置，配合 esp-01s 可以把温度数据发送到服务器，为了查看方便做了这么一个页面。 效果图 点击这里查看 录了个小视频介绍一下 源代码 Arduino 项目文件 服务端代码 Web端代码 希望对有同样需求的人有帮助]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ds18b20</tag>
        <tag>室温监控</tag>
        <tag>智能家具</tag>
        <tag>esp8266</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12. DS18B20数字温度传感器]]></title>
    <url>%2F2018%2F05%2F12%2F12-DS18B20%E6%95%B0%E5%AD%97%E6%B8%A9%E5%BA%A6%E4%BC%A0%E6%84%9F%E5%99%A8%2F</url>
    <content type="text"><![CDATA[DS18B20 介绍数字温度传感器 DS18B20。 具有体积小、硬件开销低、抗干扰能力强、精度高的特点。 常见的封装形式有：直插式、管道式、螺纹式、磁铁吸附式、不锈钢封装式等。 DS18B20的测温范围可达-55°C ~ +125°C，在-10°C ~ +85°C范围时精度为±0.5°C，工作电压3.0v ~ 5.0v。 文档链接 特性 独特的1-Wire接口只需要一个引脚进行通信 每个器件都有一个存储在板载ROM中的唯一64位串行代码 不需要其他外部辅助器件 可以从数据线供电 电源范围为3.0V至5.5V 测温范围从–55°C到+125°C (–67°F到+257°F)，–10°C到+85°C的精度为±0.5°C 分辨率9或12位可调 12位转换最多用时750ms 用户可定义的非易失性报警 单总线介绍 1-Wire是Maxim子公司达拉斯半导体的专利技术，仅用单一信号线就可像I²C、SPI一样，传输时钟（clock）又传输数据（data），并且数据传输是双向的。1-Wire使用较低的数据传输速率，通常是用来沟通小型设备，如数字温度计。 -- 维基百科 Arduino 如何使用 DS18B20 123456789101112131415161718192021222324#include &lt;OneWire.h&gt;#include &lt;DallasTemperature.h&gt;const int ONE_WIRE_BUS = 2;OneWire oneWire(ONE_WIRE_BUS);DallasTemperature sensors(&amp;oneWire);void setup(void)&#123; Serial.begin(9600); sensors.begin();&#125;void loop(void)&#123; sensors.requestTemperatures(); Serial.print(&quot;Celsius temperature: &quot;); Serial.print(sensors.getTempCByIndex(0)); Serial.print(&quot; - Fahrenheit temperature: &quot;); Serial.println(sensors.getTempFByIndex(0)); delay(1000);&#125; 51单片机如何使用 DS18B20123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include &lt;mcs51/8051.h&gt;#include &lt;stdio.h&gt;#define __nop() __asm nop __endasm#define ONE_BUS P2_0void delay_t(unsigned int t)&#123; while(t--);&#125;void delay(unsigned int t)&#123; signed int a, b; for(a=t; a&gt;0; a--) for(b=125; b&gt;0; b--);&#125;__bit one_wire_init()&#123; __bit status = 1; ONE_BUS = 1; delay_t(8); ONE_BUS = 0; delay_t(80); // 480us~960us ONE_BUS = 1; delay_t(8); status = ONE_BUS; delay_t(4); // 60us~240us return status;&#125;void one_wire_write_byte(unsigned char data)&#123; unsigned char i; for(i=0; i&lt;8; i++) &#123; ONE_BUS = 0; ONE_BUS = data &amp; 0x01; delay_t(4); // 15us~30us ONE_BUS = 1; data &gt;&gt;= 1; &#125; delay_t(4);&#125;unsigned char one_wire_read_byte()&#123; unsigned char i = 0; unsigned char data = 0; for(i=0; i&lt;8; i++) &#123; ONE_BUS = 0; data &gt;&gt;= 1; ONE_BUS = 1; if(ONE_BUS) &#123; data |= 0x80; &#125; delay_t(4); &#125; return data;&#125;void request_temperature()&#123; one_wire_init(); one_wire_write_byte(0xCC); one_wire_write_byte(0x44);&#125;unsigned char get_temperature()&#123; unsigned char lsb, msb; one_wire_init(); one_wire_write_byte(0xCC); one_wire_write_byte(0xBE); lsb = one_wire_read_byte(); msb = one_wire_read_byte(); msb &lt;&lt;= 4; msb += (lsb &gt;&gt; 4); return msb;&#125;void serial_init()&#123; TMOD |= 0x20; SCON |= 0x50; // 波特率 9600 TH1 = 0XFD; TL1 = 0XFD; // 启动定时器1 TR1=1; //中断允许 EA=1;&#125;void putchar(char c)&#123; SBUF = c; while(!TI); TI = 0;&#125;void setup()&#123; __bit status = 1; serial_init(); status = one_wire_init(); if(!status) &#123; printf(&quot;invalid status\n&quot;); &#125;&#125;void loop()&#123; char value = 0; request_temperature(); printf(&quot;value: %d \n&quot;, get_temperature()); delay(500);&#125;void main()&#123; setup(); while(1) loop();&#125; 一些有用的链接 Arduino One Wire Library Arduino Temperature Control Library DS18B20 Digital Temperature Sensor And Arduino]]></content>
      <categories>
        <category>电子器件</category>
        <category>温度传感器</category>
        <category>数字温度传感器</category>
      </categories>
      <tags>
        <tag>ds18b20</tag>
        <tag>温度传感器</tag>
        <tag>数字温度传感器</tag>
        <tag>单总线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11. 如何使用esp-01s继电器模块 和 我的WIFI控制电灯整体解决方案]]></title>
    <url>%2F2018%2F05%2F08%2F11-%E6%88%91%E7%9A%84WIFI%E6%8E%A7%E5%88%B6%E7%94%B5%E7%81%AF%E6%95%B4%E4%BD%93%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[介绍如何用WIFI控制家里的电灯？最简单的方法是使用ESP-01s和配套的relay模块。 配置Arduino IDE使其支持esp8266芯片 打开 文件/首选项/附加开发板管理器网址，添加下面的URL1http://arduino.esp8266.com/stable/package_esp8266com_index.json 打开工具/开发板/开发板管理器，安装esp8266开发板 Github: esp8266/arduino 需要使用的工具 usb-ttl一个 (须支持3.3v) 杜邦线若干 面包板一个 对 ESP-01S 烧写程序的方法 esp-01s引脚 对应usb-ttl引脚 3.3v 3.3v GND GND IO0 GND IO2 NC EN 3.3v RST NC TX RX RX TX esp-01s会在上电的瞬间检查IO0的电平，如果IO0为低点平则进入烧写模式，否则进入正常运行模式。 所以在烧写之前需要先断开esp-01s的Vcc链接，当Arduino-IDE出现开始上传的提示时插入Vcc。 烧写完成后，断开IO0与GND的连接，重新接通Vcc进入正常运行模式。 Arduino IDE 程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;ESP8266WebServer.h&gt;#include &lt;ESP8266HTTPClient.h&gt;const char* SSID = &quot;********&quot;;const char* PASSWORD = &quot;********&quot;;HTTPClient http;ESP8266WebServer server(80);const int relay = 0;String getStatusJSON() &#123; String json = &quot;&#123; \&quot;status\&quot;: 0, \&quot;data\&quot;: &#123; \&quot;status\&quot;: &quot;; json += digitalRead(relay); json += &quot; &#125; &#125;&quot;; return json;&#125;void connectWiFi(const char *ssid, const char *password) &#123; WiFi.begin(ssid, password); Serial.printf(&quot;connecting to %s\n&quot;, SSID); while (WiFi.status() != WL_CONNECTED) &#123; delay(500); Serial.print(&quot;.&quot;); &#125; Serial.printf(&quot;\nconnected to %s\n&quot;, ssid); Serial.print(&quot;ip address is: &quot;); Serial.println(WiFi.localIP());&#125;void setup(void)&#123; Serial.begin(115200); pinMode(relay, OUTPUT); digitalWrite(relay, 1); WiFi.mode(WIFI_STA); connectWiFi(SSID, PASSWORD); server.on(&quot;/on&quot;, []() &#123; digitalWrite(relay, LOW); server.send(200, &quot;text/json&quot;, getStatusJSON()); &#125;); server.on(&quot;/off&quot;, []() &#123; digitalWrite(relay, HIGH); server.send(200, &quot;text/json&quot;, getStatusJSON()); &#125;); server.on(&quot;/status&quot;, []() &#123; server.send(200, &quot;text/json&quot;, getStatusJSON()); &#125;); server.onNotFound([]() &#123; server.send(404, &quot;text/plain&quot;, &quot;Not Found&quot;); &#125;); server.begin(); Serial.println(&quot;HTTP server started&quot;);&#125;void loop(void)&#123; while (WiFi.status() == WL_CONNECT_FAILED || WiFi.status() == WL_CONNECTION_LOST || WiFi.status() == WL_DISCONNECTED) &#123; Serial.printf(&quot;reconnect to %s\n&quot;, SSID); connectWiFi(SSID, PASSWORD); &#125; server.handleClient();&#125; 我的完整解决方案 视频中的源代码 https://github.com/hungtcs-lab/ionic-esp01-relay-controller https://github.com/hungtcs-lab/esp01-relay-manager]]></content>
      <categories>
        <category>单片机</category>
        <category>esp8266</category>
      </categories>
      <tags>
        <tag>esp-01s</tag>
        <tag>智能家居</tag>
        <tag>WIFI Module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10. GateOne安装后启动报错的解决方法]]></title>
    <url>%2F2018%2F04%2F25%2F10-GateOne%E5%AE%89%E8%A3%85%E5%90%8E%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[错误日志1234567891011121314151617181920212223Traceback (most recent call last): File &quot;/usr/local/bin/gateone&quot;, line 9, in &lt;module&gt; load_entry_point(&#x27;gateone==1.2.0&#x27;, &#x27;console_scripts&#x27;, &#x27;gateone&#x27;)() File &quot;/usr/lib/python2.7/dist-packages/pkg_resources/__init__.py&quot;, line 542, in load_entry_point return get_distribution(dist).load_entry_point(group, name) File &quot;/usr/lib/python2.7/dist-packages/pkg_resources/__init__.py&quot;, line 2569, in load_entry_point return ep.load() File &quot;/usr/lib/python2.7/dist-packages/pkg_resources/__init__.py&quot;, line 2229, in load return self.resolve() File &quot;/usr/lib/python2.7/dist-packages/pkg_resources/__init__.py&quot;, line 2235, in resolve module = __import__(self.module_name, fromlist=[&#x27;__name__&#x27;], level=0) File &quot;/usr/local/lib/python2.7/dist-packages/gateone-1.2.0-py2.7.egg/gateone/core/server.py&quot;, line 402, in &lt;module&gt; from gateone.auth.authorization import require, authenticated, policies File &quot;/usr/local/lib/python2.7/dist-packages/gateone-1.2.0-py2.7.egg/gateone/auth/authorization.py&quot;, line 38, in &lt;module&gt; @memoize File &quot;/usr/local/lib/python2.7/dist-packages/gateone-1.2.0-py2.7.egg/gateone/core/utils.py&quot;, line 290, in __init__ MEMO = AutoExpireDict(timeout=timeout, interval=&quot;30s&quot;) File &quot;/usr/local/lib/python2.7/dist-packages/gateone-1.2.0-py2.7.egg/gateone/core/utils.py&quot;, line 161, in __init__ self.interval = kwargs.pop(&#x27;interval&#x27;) File &quot;/usr/local/lib/python2.7/dist-packages/gateone-1.2.0-py2.7.egg/gateone/core/utils.py&quot;, line 211, in interval self._timeout_checker, value, io_loop=self.io_loop)TypeError: __init__() got an unexpected keyword argument &#x27;io_loop&#x27;Exception AttributeError: &quot;&#x27;AutoExpireDict&#x27; object has no attribute &#x27;_key_watcher&#x27;&quot; in &lt;bound method AutoExpireDict.__del__ of &#123;&#125;&gt; ignored 产生原因由于tornado最新版本与旧版本不兼容导致 解决方法安装4.5版本 1sudo pip install tornado==4.5.3]]></content>
      <categories>
        <category>Linux</category>
        <category>Softwares</category>
      </categories>
      <tags>
        <tag>GateOne</tag>
        <tag>Web SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9. 74HC595的使用方法(STM8S控制)]]></title>
    <url>%2F2018%2F04%2F17%2F9-74HC595%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95-STM8S%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[器件简介 74HC595是一个8位串行输入、并行输出的位移缓存器：并行输出为三态输出。 在SCK 的上升沿，串行数据由SDL输入到内部的8位位移缓存器，并由Q7’输出，而并行输出则是在LCK的上升沿将在8位位移缓存器的数据存入到8位并行输出缓存器。 当串行数据输入端OE的控制信号为低使能时，并行输出端的输出值等于并行输出缓存器所存储的值。 而当OE为高电位，也就是输出关闭时，并行输出端会维持在高阻抗状态。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdint.h&gt;#include &quot;stm8s.h&quot;#define __nop() __asm nop __endasmunsigned char data = 0x01;void delay() &#123; uint32_t i; for(i = 0; i &lt; 5000; i++) __asm nop __endasm;&#125;void setup()&#123; PD_DDR = 0xFF; PD_CR1 = 0xFF; PD_CR2 = 0x00;&#125;void loop()&#123; unsigned char i; for(i=0; i&lt;8; i++) &#123; if((data &gt;&gt; i) &amp; 0x01) PD_ODR |= 0x08; else PD_ODR &amp;= 0xF7; PD_ODR &amp;= 0xFB; __nop(); __nop(); __nop(); __nop(); __nop(); PD_ODR |= 0x04; &#125; PD_ODR &amp;= 0xFD; __nop(); __nop(); __nop(); __nop(); __nop(); PD_ODR |= 0x02; data &lt;&lt;= 1; if(data == 0) data = 0x01; delay();&#125;void main()&#123; setup(); while(1) loop();&#125; 1234// 编译sdcc -mstm8 -lstm8 --out-fmt-ihx -o build/ main.c// 烧写sudo stm8flash -c stlinkv2 -p stm8s103f3 -w build/main.ihx]]></content>
      <categories>
        <category>单片机</category>
        <category>STM8单片机</category>
      </categories>
      <tags>
        <tag>74HC595</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8. 51单片机使用PCF8591(ADC/DAC)的方法(AD篇)]]></title>
    <url>%2F2018%2F04%2F07%2F8-51%E5%8D%95%E7%89%87%E6%9C%BA%E4%BD%BF%E7%94%A8PCF8591-ADC-DAC-%E7%9A%84%E6%96%B9%E6%B3%95-IIC%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[PCF8591介绍 PCF8591 是具有 I2C 总线接口的 8 位 A/D 及 D/A 转换器。 有 4 路 A/D 转换输入,1 路 D/A 模拟输出。 这就是说,它既可以作 A/D 转换也可以作 D/A 转换。 A/D 转换为逐次比较型。 电源电压典型值为 5V。 I2C 总线是 Philips 公司推出的新型单片机系统。 它采用串行总线,主控器与外围器件仅靠两条线进行信息传输,一条称为时钟线(SCL),另一条位数据线(SDA)。 I2C 总线单片机系统较通用单片机系统电路简单。 由普通 CPU 芯片同 I2C 专用器件组成的系统为模拟 I2C 系统,它性能稳定,价格较低,目前已得到广泛应用。 文档链接 PCF8591引脚 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// file: main.c#include &lt;8051.h&gt;#include &lt;stdio.h&gt;#include &quot;delay.h&quot;#include &quot;iic.h&quot;void setup()&#123; // 定时器工作模式设置 // 定时器0为工作模式1 用于计时 // 定时器1为工作模式2 用于串口 TMOD = 0x20; // 设置串口为模式1 // SM0 0 // SM1 1 SCON |= 0x50; // 设置定时器1初值和自动装载值 // 波特率 9600 TH1 = 0XFD; TL1 = 0XFD; // 启动定时器1 TR1=1; //中断允许 EA=1; SDA = 1; SCL = 1;&#125;void loop()&#123; unsigned char data; iic_start(); iic_send_byte(0x90); iic_send_byte(0x04); iic_start(); iic_send_byte(0x91); iic_receive_byte(); iic_ack(0); data = iic_receive_byte(); printf(&quot;value 1: %d &quot;, data); iic_ack(0); data = iic_receive_byte(); printf(&quot;value 2: %d &quot;, data); iic_ack(0); data = iic_receive_byte(); printf(&quot;value 3: %d &quot;, data); iic_ack(0); data = iic_receive_byte(); printf(&quot;value 4: %d\n&quot;, data); iic_ack(1); iic_stop(); delay(100);&#125;void main()&#123; setup(); while(1) loop();&#125;void putchar(char c)&#123; SBUF = c; while(!TI); TI = 0;&#125; 123456789101112131415161718// iic.h#include &lt;8051.h&gt;#ifndef __IIC_H__#define __IIC_H__#define SDA P1_2#define SCL P1_7#define __nop __asm nop __endasmextern void iic_start();extern void iic_stop();extern void iic_ack(__bit ack);extern __bit iic_send_byte(unsigned char data);extern unsigned char iic_receive_byte();#endif // __IIC_H__ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// file: iic.c#include &quot;iic.h&quot;void iic_start()&#123; SDA = 1; SCL = 1; __nop; __nop; __nop; __nop; __nop; SDA = 0; __nop; __nop; __nop; __nop; __nop; SCL = 0;&#125;void iic_stop()&#123; SDA = 0; SCL = 1; __nop; __nop; __nop; __nop; __nop; SDA = 1; __nop; __nop; __nop; __nop; __nop; // SCL = 0;&#125;void iic_ack(__bit ack)&#123; SDA = ack; SCL = 1; __nop; __nop; __nop; __nop; __nop; SCL = 0;&#125;__bit iic_send_byte(unsigned char data)&#123; __bit ack; unsigned char i; SCL = 0; for(i=0; i&lt;8; i++) &#123; SDA = data &amp; 0x80; data &lt;&lt;= 1; SCL = 1; __nop; __nop; __nop; __nop; __nop; SCL = 0; &#125; SDA = 1; SCL = 1; __nop; __nop; __nop; __nop; __nop; ack = SDA; SCL = 0; return ack;&#125;unsigned char iic_receive_byte()&#123; unsigned char i, data = 0; for(i=0; i&lt;8; i++) &#123; SDA = 1; SCL = 1; data &lt;&lt;= 1; if(SDA == 1) &#123; data |= 0x01; &#125; SCL = 0; &#125; return data;&#125; 123456789101112131415// file: delay.h#ifndef __DELAY_H__#define __DELAY_H__void delay(unsigned int time)&#123; unsigned char i, j; while(time--) &#123; for(i=3; i&gt;0; i--) for(j=100; j&gt;0; j--); &#125;&#125;#endif // __DELAY_H__]]></content>
      <categories>
        <category>单片机</category>
        <category>51单片机</category>
      </categories>
      <tags>
        <tag>PCF8591</tag>
        <tag>AD</tag>
        <tag>DA</tag>
        <tag>模数转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7. 51单片机使用LCD12864液晶屏（串行方式）]]></title>
    <url>%2F2018%2F04%2F05%2F7-51%E5%8D%95%E7%89%87%E6%9C%BA%E4%BD%BF%E7%94%A8LCD12864%E6%B6%B2%E6%99%B6%E5%B1%8F%EF%BC%88%E4%B8%B2%E8%A1%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[模块介绍 液晶显示模块是 128×64 点阵的汉字图形型液晶显示模块，可显示汉字及图形， 内置 8192 个中文汉字（16X16 点阵）、128 个字符（8X16 点阵）及 64X256 点阵显示 RAM（GDRAM）。 可与 CPU 直接接口，提供两种界面来连接微处理机：8位并行及串行两种连接方式。 具有多种功能：光标显示、画面移位、睡眠模式等。 此实例采用串行方式 并行方式请查看： 6. 51单片机使用LCD12864液晶屏（8位并行） 文档链接 引脚定义 串行时序 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111/** * lcd12864_write_data * lcd12864_write_command * 方法与并行不同，其他部分基本一致 */#include &lt;8052.h&gt;#include &quot;delay.h&quot;#define CS P0_0#define SID P0_1#define SCLK P0_2void lcd12864_write(unsigned char data)&#123; unsigned char i; for(i=0; i&lt;8; i++) &#123; SCLK = 0; SID = data &amp; 0x80; data &lt;&lt;= 1; SCLK = 1; &#125;&#125;void lcd12864_write_command(unsigned char command)&#123; // RW = 0; RS = 0 lcd12864_write(0xF8); lcd12864_write(command &amp; 0xF0); lcd12864_write((command &lt;&lt; 4) &amp; 0xF0); delay_50us(4);&#125;void lcd12864_write_data(unsigned char data)&#123; // RW = 0; RS = 1 lcd12864_write(0xFA); lcd12864_write(data &amp; 0xF0); lcd12864_write((data &lt;&lt; 4) &amp; 0xF0); delay_50us(4);&#125;void lcd12864_initialization()&#123; CS = 1; delay(100); lcd12864_write_command(0x30); delay_50us(4); lcd12864_write_command(0x30); delay_50us(4); lcd12864_write_command(0x0f); delay_50us(4); lcd12864_write_command(0x01); delay(15); lcd12864_write_command(0x06); CS = 0;&#125;void display_chinese_characters()&#123; // 您好！ // 从字符表查到的编码 unsigned char table[] = &#123; 0xC4, 0xFA, 0xBA, 0xC3, 0xA3, 0xA1 &#125;; unsigned char i; CS = 1; // 第二行地址从0x90开始 lcd12864_write_command(0x90); for(i=0; i&lt;sizeof(table); i++) &#123; lcd12864_write_data(table[i]); &#125; CS = 0;&#125;void display_ascii()&#123; unsigned char i; unsigned char table[] = &quot;hello world!&quot;; CS = 1; // 第一行地址从0x80开始 lcd12864_write_command(0x80); for(i=0; i&lt;sizeof(table); i++) &#123; lcd12864_write_data(table[i]); &#125; // 接着是第三行，第三行地址从0x88开始 lcd12864_write_command(0x88); for(i=0; i&lt;sizeof(table); i++) &#123; lcd12864_write_data(table[i]); &#125; CS = 0;&#125;void setup()&#123; lcd12864_initialization(); display_ascii(); display_chinese_characters();&#125;void loop()&#123;&#125;void main()&#123; setup(); while(1) loop();&#125;]]></content>
      <categories>
        <category>单片机</category>
        <category>51单片机</category>
      </categories>
      <tags>
        <tag>LCD12864</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6. 51单片机使用LCD12864液晶屏（8位并行）]]></title>
    <url>%2F2018%2F04%2F04%2F6-51%E5%8D%95%E7%89%87%E6%9C%BA%E4%BD%BF%E7%94%A8LCD12864%E6%B6%B2%E6%99%B6%E5%B1%8F%2F</url>
    <content type="text"><![CDATA[模块介绍 液晶显示模块是 128×64 点阵的汉字图形型液晶显示模块，可显示汉字及图形， 内置 8192 个中文汉字（16X16 点阵）、128 个字符（8X16 点阵）及 64X256 点阵显示 RAM（GDRAM）。 可与 CPU 直接接口，提供两种界面来连接微处理机：8位并行及串行两种连接方式。 具有多种功能：光标显示、画面移位、睡眠模式等。 此实例采用8位并行方式 文档链接 引脚定义 图片 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// file: main.c#include &lt;8052.h&gt;#include &quot;delay.h&quot;#define RS P1_0#define RW P1_1#define EN P2_5#define PSB P1_3#define DATA_PORT P0void lcd12864_write_command(unsigned char command)&#123; RS = 0; RW = 0; DATA_PORT = command; EN = 1; delay_50us(10); EN = 0;&#125;void lcd12864_write_data(unsigned char data)&#123; RS = 1; RW = 0; DATA_PORT = data; EN = 1; delay_50us(10); EN = 0;&#125;void lcd12864_initialization()&#123; delay(100); lcd12864_write_command(0x30); delay_50us(4); lcd12864_write_command(0x30); delay_50us(4); lcd12864_write_command(0x0f); delay_50us(4); lcd12864_write_command(0x01); delay(15); lcd12864_write_command(0x06);&#125;void display_chinese_characters()&#123; // 您好！ // 从字符表查到的编码 unsigned char table[] = &#123; 0xC4, 0xFA, 0xBA, 0xC3, 0xA3, 0xA1 &#125;; unsigned char i; // 第二行地址从0x90开始 lcd12864_write_command(0x90); for(i=0; i&lt;sizeof(table); i++) &#123; lcd12864_write_data(table[i]); &#125;&#125;void display_ascii()&#123; unsigned char i; unsigned char table[] = &quot;hello world!&quot;; // 第一行地址从0x80开始 lcd12864_write_command(0x80); for(i=0; i&lt;sizeof(table); i++) &#123; lcd12864_write_data(table[i]); &#125; // 接着是第三行，第三行地址从0x88开始 lcd12864_write_command(0x88); for(i=0; i&lt;sizeof(table); i++) &#123; lcd12864_write_data(table[i]); &#125;&#125;void setup()&#123; lcd12864_initialization(); display_ascii(); display_chinese_characters();&#125;void loop()&#123;&#125;void main()&#123; setup(); while(1) loop();&#125; 123456789101112131415161718192021222324252627282930313233// file: delay.h#ifndef __DELAY__#define __DELAY__/** * 毫秒延时 * 晶震 11.0592MHz */void delay(unsigned int millisecond)&#123; unsigned char a,b; while(millisecond--) &#123; for(b=102;b&gt;0;b--) for(a=3;a&gt;0;a--); &#125;&#125;/** * 50微秒延时 * 晶震 11.0592MHz */void delay_50us(unsigned int times)&#123; unsigned char a,b; while(times--) &#123; for(b=1;b&gt;0;b--) for(a=20;a&gt;0;a--); &#125;&#125;#endif // __DELAY__ 演示效果]]></content>
      <categories>
        <category>单片机</category>
        <category>51单片机</category>
      </categories>
      <tags>
        <tag>LCD12864</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5. 51单片机使用超声波模块（HC-SR04）]]></title>
    <url>%2F2018%2F04%2F01%2F5-51%E5%8D%95%E7%89%87%E6%9C%BA%E4%BD%BF%E7%94%A8%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%EF%BC%88HC-SR04%EF%BC%89%2F</url>
    <content type="text"><![CDATA[基本工作原理 采用IO口TRIG触发测距，给至少10us的高电平信号 模块自动发送8个40khz的方波，自动检测是否有信号返回 有信号返回，通过IO口ECHO输出一个高电平，高电平持续的时间就是超声波从发射到返回的时间 测试距离 = (高电平时间 * 声速(340M/S)) / 2 硬件配置 名称 型号 主控 STC89C52RC 晶震 11.0592MHz 超声波模块 HC-SR04 空气中的音速在1个标准大气压和15℃的条件下约为340m/s（0.34m/ms） 51单片机定时器工模式1最大定时时间为65535 * 12 * 1 / 11.0592=71.11ms HC-SR04最大探测距离位4m，声音在上面的条件下传播4m需要的时间约为11.76ms 所以我们只需要读取定时器TH和TL的值就可以了 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;mcs51/8051.h&gt;#include &lt;stdio.h&gt;#define __nop__ __asm nop __endasm#define TRIG P0_0#define ECHO P0_1__bit isOverstep = 0;// 返回时间int time, distance;void calculate()&#123; // 读取定时器的值 time = TH0 * 256 + TL0; // 重置定时器初值 TH0 = 0; TL0 = 0; time *= 1.085; // 音速 = 340m/s = 0.34m/ms = 0.00034m/us = 0.034cm/us // 距离 = 高电平时间 * 音速 / 2 distance = (time * 0.017); if(isOverstep) &#123; isOverstep = 0; printf(&quot;overstep\n&quot;); &#125; else &#123; printf(&quot;distance = %dcm\n&quot;, distance); &#125;&#125;void trigger()&#123; TRIG = 1; // 高点平持续10us以上 __nop__; __nop__; __nop__; __nop__; __nop__; __nop__; __nop__; __nop__; __nop__; __nop__; __nop__; __nop__; __nop__; __nop__; __nop__; __nop__; __nop__; __nop__; __nop__; __nop__; TRIG = 0;&#125;void setup()&#123; // 定时器工作模式设置 // 定时器0为工作模式1 用于计时 // 定时器1为工作模式2 用于串口 TMOD = 0x21; // 设置串口为模式1 // SM0 0 // SM1 1 SCON |= 0x50; // 设置定时器1初值和自动装载值 // 波特率 9600 TH1 = 0XFD; TL1 = 0XFD; // 设置定时器0初值 TH0=0; TL0=0; // 定时器T0中断允许 ET0=1; // 启动定时器1 TR1=1; //中断允许 EA=1;&#125;void loop()&#123; // 出发超声波模块 trigger(); // 等待回响 while(!ECHO); // 启动定时器0 TR0 = 1; // 等待回响结束 while(ECHO); // 停止定时器0 TR0=0; // 计算并输出 calculate();&#125;void timer0() __interrupt 1&#123; isOverstep = 1;&#125;void main()&#123; setup(); while(1) loop();&#125;void putchar(char c)&#123; SBUF = c; while(!TI); TI = 0;&#125; 串口输出]]></content>
      <categories>
        <category>单片机</category>
        <category>51单片机</category>
      </categories>
      <tags>
        <tag>超声波模块</tag>
        <tag>HC-SR04</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4. 使用NodeJS原生API创建Http Server的方法]]></title>
    <url>%2F2018%2F03%2F29%2F4-%E4%BD%BF%E7%94%A8NodeJS%E5%8E%9F%E7%94%9FAPI%E5%88%9B%E5%BB%BAHttp-Server%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在使用Koa写服务，发现自己一直使用的都是Express之类的框架，却不知道NodeJS原生的Http API使用方法，遂查阅了文档，在此处记一下 1234567891011121314151617181920212223242526272829#!/usr/bin/env nodeconst url = require(&#x27;url&#x27;);const http = require(&#x27;http&#x27;);const querystring = require(&#x27;querystring&#x27;);const server = http.createServer((request, response) =&gt; &#123; try &#123; if(request.method === &quot;GET&quot;) &#123; response.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html&#x27; &#125;); let &#123; query &#125; = url.parse(request.url, true); response.write(`hello $&#123; query.name || &#x27;world&#x27; &#125;!`); &#125; else if(request.method == &quot;POST&quot;) &#123; response.writeHead(405, &#123; &#x27;Content-Type&#x27;: &#x27;text/html&#x27; &#125;); response.write(`Method Not Allowed!`); &#125; &#125; catch (err) &#123; response.writeHead(500, &#123; &#x27;Content-Type&#x27;: &#x27;text/json&#x27; &#125;); response.write(JSON.stringify(err)); &#125; finally &#123; response.end(); &#125;&#125;);server.listen(3000);]]></content>
      <categories>
        <category>JavaScript</category>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3. Arduino 使用超声波模块（HC-SR04）]]></title>
    <url>%2F2018%2F03%2F28%2F3-Arduino-%E4%BD%BF%E7%94%A8%E8%B6%85%E5%A3%B0%E6%B3%A2%E6%A8%A1%E5%9D%97%EF%BC%88HC-SR04%EF%BC%89%2F</url>
    <content type="text"><![CDATA[接线图 基本工作原理 采用IO口TRIG触发测距，给至少10us的高电平信号 模块自动发送8个40khz的方波，自动检测是否有信号返回 有信号返回，通过IO口ECHO输出一个高电平，高电平持续的时间就是超声波从发射到返回的时间 测试距离 = (高电平时间 * 声速(340M/S)) / 2 代码1234567891011121314151617181920212223242526const int trigPin = 7;const int echoPin = 8;void setup() &#123; pinMode(trigPin, OUTPUT); pinMode(echoPin, INPUT); Serial.begin(9600);&#125;void loop() &#123; long duration, distance; digitalWrite(trigPin, LOW); delayMicroseconds(2); digitalWrite(trigPin, HIGH); delayMicroseconds(40); digitalWrite(trigPin, LOW); // 读取echoPin，以微秒为单位返回高电平持续时间 duration = pulseIn(echoPin, HIGH); distance= duration * 0.034 / 2; Serial.print(&quot;Distance: &quot;); Serial.println(distance);&#125; 串口输出]]></content>
      <categories>
        <category>Arduino</category>
      </categories>
      <tags>
        <tag>Arduino</tag>
        <tag>Arduino Uno</tag>
        <tag>超声波模块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2. 8051驱动 LCD1602 例子]]></title>
    <url>%2F2018%2F03%2F28%2F2.%208051%E9%A9%B1%E5%8A%A8%20LCD1602%20%E4%BE%8B%E5%AD%90%2F</url>
    <content type="text"><![CDATA[配套电路图 C程序代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;8051.h&gt;#define true 1#define false 0#define HIGH 1#define LOW 0/** * LCD1602 的测试例子 * * @author 鸿则&lt;hungtcs@163.com&gt; * @Date 2018-02-11 */// LCD1602 define#define LCD1602_E P2_6#define LCD1602_RS P2_4#define LCD1602_RW P2_5// length is 16unsigned char line1[] = &quot; hello world! &quot;;unsigned char line2[] = &quot;~!@#$%^&amp;*()_+[]?&quot;;void delay(unsigned int multiple)&#123; unsigned int i; for(; multiple&gt;0; multiple--) for(i=100; i&gt;0; i--);&#125;void writeCommand(unsigned char command)&#123; LCD1602_E = LOW; LCD1602_RS = LOW; LCD1602_RW = LOW; P0 = command; delay(10); LCD1602_E = HIGH; delay(20); LCD1602_E = LOW;&#125;void writeData(unsigned char data)&#123; LCD1602_E = LOW; LCD1602_RS = HIGH; LCD1602_RW = LOW; P0 = data; delay(10); LCD1602_E = HIGH; delay(20); LCD1602_E = LOW;&#125;void initLCD1602()&#123; delay(300); writeCommand(0x38); delay(100); writeCommand(0x38); delay(100); writeCommand(0x38); writeCommand(0x38); writeCommand(0x08); writeCommand(0x01); writeCommand(0x06); writeCommand(0x0C);&#125;void setup()&#123; unsigned char i; initLCD1602(); for(i=0; i&lt;16; i++) &#123; writeCommand(0x80 + i); writeData(line1[i]); delay(10); &#125; for(i=0; i&lt;16; i++) &#123; writeCommand(0x80 + 0x40 + i); writeData(line2[i]); delay(10); &#125;&#125;void loop()&#123;&#125;void main()&#123; setup(); while(true) loop();&#125;]]></content>
      <categories>
        <category>单片机</category>
        <category>51单片机</category>
      </categories>
      <tags>
        <tag>LCD1602</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1. nRF24l01使用说明]]></title>
    <url>%2F2018%2F03%2F27%2F1.%20nRF24l01%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[Enhanced ShockBurstTM 发送流程 把地址和要发送的数据按时序送入nRF24l01 配置config寄存器，使之进入发送模式 把CE置高（至少10us），激发Enhanced ShockBurstTM发射 Enhanced ShockBurstTM 发送模式初始化流程 写Tx节点地址 TX_ADDR 写Rx节点的地址（使能auto ack） RX_ADDR_P0 使能auto ack EN_AA 使能PIPE0 EN_RXADDR 配置自动重发次数 SETUP_RETR 选择通信频率 RF_CH (2400 + RF_CH MHz) (0~125) 配置发射参数（低噪方法增益、发射功率、无线速率） RF_SETUP 配置24l01的基本参数以及切换工作模式 CONFIG Enhanced ShockBurstTM 接收流程 配置接收地址和要接收的数据包大小 配置CONFIG寄存器，使之进入接收模式，置高CE 130us后，nrf24l01进入监视状态，等待接收数据包 当接收到正确的数据包，nrf24l01自动去除字头、地址和CRC校验码 nrf24l01通过把STATUS寄存器的RX_DR置位（引起微控制器中断）通知微控制器 微控制器把数据从FIFO读出（0x61指令） 数据读取完毕后，可以清楚STATUS寄存器。nrf24l01进入四种主要模式之一 Enhanced ShockBurstTM 接收模式初始化 写Rx节点的地址 RX_ADDR_P0 使能auto ack EN_AA 使能PIPE0 EN_RX_ADDR 选择通信频率 RF_CH 选择通道0有效数据宽度 RX_PW_P0 配置发射参数（低噪放大增益、发射功率、无线速率） RF_SETUP 配置24l01的基本参数以切换工作模式 CONFIG SPI指令 指令名称 指令格式 操作 R_REGISTER 000A AAAA 读寄存器。A AAAA为要读取的寄存器地址 W_REGISTER 001A AAAA 写寄存器。 R_RX_PAYLOAD 0110 0001 读RX有效数据，1～32字节。读取操作从字节0开始，当读RX有效数据完成后，FIFO寄存器中的使有效数据将被清除。接收模式下使用 W_TX_PAYLOAD 1010 0000 写有效数据，1～32字节。写操作从字节0开始。发送模式下用。 FLUSH_TX 1110 0001 清除TX FIFO寄存器。发送模式下用。 FLUSH_RX 1110 0010 清除RX FIFO寄存器。接收模式下用。 1234567#define NRF_READ_REG 0x00#define NRF_WRITE_REG 0x20#define RD_RX_PLOAD 0x61#define WR_TX_PLOAD 0xA0#define FLUSH_TX 0xE1#define FLUSH_RX 0xE2#define NOP 0xFF CONFIG寄存器 地址 参数 位 复位值 类型 描述 0x00 CONFIG 配置寄存器 Reserved 7 0 R/W 保留位 MASK_RX_DR 6 0 R/W 可屏蔽中断 RX_RD 1: IRQ引脚不输出RX_RD中断0: RX_RD中断时，IRQ输出低电平 MASK_TX_DS 5 0 R/W 可屏蔽中断 TX_DS 1: IRQ引脚不输出TX_DS中断0: RX_DS中断时，IRQ输出低电平 MASK_MAX_RT 4 0 R/W 可屏蔽中断 MAX_RT1: IRQ引脚不输出MAX_RT中断0: MAX_RT中断时，IRQ输出低电平 EN_CRC 3 1 R/W CRC使能。如果EN_AA中任意一位置高，则EN_CRC强迫为高 CRCO 2 0 R/W CRC模式。0: 8位CRC1: 16位CRC PWR_UP 1 0 R/W 1: 上电0: 掉电 PRIM_RX 0 0 R/W 1: 接收模式0: 发送模式 自动应答使能寄存器 EN_AA 地址 参数 位 复位值 类型 描述 0x01 EN_AA 自动应答使能寄存器 同时可以使能Enhanced模式 Reserved 7~6 0 R/W 保留位 ENAA_P5 5 1 R/W 数据通道5,自动应答允许 ENAA_P4 4 1 R/W 数据通道4,自动应答允许 ENAA_P3 3 1 R/W 数据通道3,自动应答允许 ENAA_P2 2 1 R/W 数据通道2,自动应答允许 ENAA_P1 1 1 R/W 数据通道1,自动应答允许 ENAA_P0 0 1 R/W 数据通道0,自动应答允许 RX地址使能寄存器 地址 参数 位 复位值 类型 描述 0x02 EN_RX_ADDR RX地址使能寄存器 Reserved 7~6 0 R/W 保留位 ERX_P5 5 1 R/W 数据接收通道5使能 ERX_P4 4 1 R/W 数据接收通道4使能 ERX_P3 3 1 R/W 数据接收通道3使能 ERX_P2 2 1 R/W 数据接收通道2使能 ERX_P1 1 1 R/W 数据接收通道1使能 ERX_P0 0 1 R/W 数据接收通道0使能 自动重发设置寄存器 地址 参数 位 复位值 类型 描述 0x04 SETUP_RETR 自动重发设置寄存器 ARD 7~4 0000 R/W 自动重发延时0000~1111 -&gt; 85us+250*(ARD+1)us ARC 3~0 0000 R/W 自动重发次数0000~1111 -&gt; 0代表禁止 射频频率设置寄存器 地址 参数 位 复位值 类型 描述 0x05 RF_CH 射频频率设置寄存器 Reserved 7 0 R/W 保留位 RF_CH 6~0 000 0010 R/W 0~125,设置nrf24l01的射频频率 射频配置寄存器 地址 参数 位 复位值 类型 描述 0x06 RF_SETUP 射频配置寄存器 COUNT_WAVE 7 0 R/W 使能连续载波发送 Reserved 6 0 R/W 保留位 RF_DR_LOW 5 0 R/W 射频数据速率设置低位1: 250Kbps PLL_LOCK 4 0 R/W PLL_LOCK允许，仅用于测试模式 RF_DR_HIGH 3 0 R/W 射频数据速率设置高位，和低位配置设置速率[ RF_DR_HIGH RF_DR_LOW ]00: 1Mbps 10: 2Mbps 01: 250Kbps 11: 保留 RF_PWR 2~1 11 R/W 设置射频输出功率00: -18dBm 01: -12dBm 10: -6dBm 11: 0bBm Obsolete 0 1 R/W - 状态寄存器 地址 参数 位 复位值 类型 描述 0x07 STATUS 状态寄存器 Reserved 7 0 R/W 保留位 RX_DR 6 0 R/W 数据接收标志，收到数据后置一。写1清0 TX_DS 5 0 R/W 数据发送完成标志，如果工作在自动应答模式，则必须收到ACK才会置1。写1清0 MAX_RT 4 0 R/W 达到最大重发次数。写1清0 RX_P_NO 3~1 111 R/W 接收数据通道000~111: 数据通道号 110: 未使用 111: RX_FIFO寄存器空 TX_FULL 0 1 R/W TX_FIFO寄存器满标志1: 满 0: 未满 数据通道接收地址寄存器 地址 参数 位 复位值 类型 描述 0x0A RX_ADDR_P0 数据通道0接收地址寄存器 RX_ADDR_P0 39~0 0xe7e7e7e7e7 R/W 数据通道0接收地址寄存器,最大长度5个字节由SETUP_AW(0x03)寄存器控制地址长度(默认是5个字节) 类似的，还有通道1~5接收地址 设置寄存器： RX_ARRD_P1~5。 不过P1~P5共用32位高位地址，由P1设置， P2~P4只可以设置8位地址（低8位）。 发送地址设置寄存器 地址 参数 位 复位值 类型 描述 0x10 TX_ADDR 发送地址设置寄存器 TX_ADDR 39~0 0xe7e7e7e7e7 R/W 发送地址设置（先写低字节）。在Enhanced模式下，RX_ADDR_P0的地址应与此地址相同 接收通道有效数据宽度设置寄存器 地址 参数 位 复位值 类型 描述 0x11 RX_PW_P0 接收通道0有效数据宽度设置寄存器 Reserved 7~6 0 R/W 保留位 RX_PW_P0 5~0 0 R/W 数据通道0接收区有效数据宽度0: 非法 1~32: 表示1~32字节 类似的还有通道1～5有效数据宽度设置寄存器： RX_PW_P1~5， 对应通道1～5的接收有效数据宽度，方法同RX_PW_P0]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>nRF24l01</tag>
      </tags>
  </entry>
</search>
